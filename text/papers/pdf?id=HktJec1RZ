Under review as a conference paper at ICLR 2018
TOWARDS NEURAL PHRASE-BASED MACHINE TRANSLATION
Anonymous authors Paper under double-blind review
ABSTRACT
In this paper, we present Neural Phrase-based Machine Translation (NPMT). Our method explicitly models the phrase structures in output sequences using SleepWAke Networks (SWAN), a recently proposed segmentation-based sequence modeling method. To mitigate the monotonic alignment requirement of SWAN, we introduce a new layer to perform (soft) local reordering of input sequences. Different from existing neural machine translation (NMT) approaches, NPMT does not use attention-based decoding mechanisms. Instead, it directly outputs phrases in a sequential order. Our experiments show that NPMT achieves superior performances on IWSLT 2014 German-English/English-German and IWSLT 2015 English-Vietnamese machine translation tasks compared with strong NMT baselines. We also observe that our method produces meaningful phrases in output languages.
1 INTRODUCTION
A word can be considered as a basic unit in languages. However, in many cases, we often need a phrase to express a concrete meaning. For example, consider understanding the following sentence, "machine learning is a field of computer science". It may become easier to comprehend if we segment it as "[machine learning] [is] [a field of] [computer science]", where the words in the bracket `[]' are regarded as "phrases". These phrases have their own meanings, and can often be reused in other contexts.
The goal of this paper is to explore the use of phrase structures aforementioned for neural networkbased machine translation systems (Sutskever et al., 2014; Bahdanau et al., 2015). To this end, we develop a neural machine translation method that explicitly models phrases in target language sequences. Traditional phrase-based statistical machine translation (SMT) approaches have been shown to consistently outperform word-based ones (Koehn et al., 2003; Koehn, 2009; Lopez, 2008). However, modern neural machine translation (NMT) methods (Sutskever et al., 2014; Bahdanau et al., 2015; Luong et al., 2015) do not have an explicit treatment on phrases, but they still work surprisingly well and have been deployed to industrial systems (Zhou et al., 2016; Wu et al., 2016). The proposed Neural Phrase-based Machine Translation (NPMT) method tries to explore the advantages from both kingdoms. It builds upon Sleep-WAke Networks (SWAN), a segmentation-based sequence modeling technique described in Wang et al. (2017a), where segments (or phrases) are automatically discovered given the data. However, SWAN requires monotonic alignments between inputs and outputs. This is often not an appropriate assumption in many language pairs. To mitigate this issue, we introduce a new layer to perform (soft) local reordering on input sequences. Experimental results show that NPMT outperforms attention-based NMT baselines in terms of the BLEU score (Papineni et al., 2002) on IWSLT 2014 German-English/English-German and IWSLT 2015 English-Vietnamese translation tasks. We believe our method is one step towards the full integration of the advantages from neural machine translation and phrase-based SMT.
This paper is organized as follows. Section 2 presents the neural phrase-based machine translation model. Section 3 demonstrates the usefulness of our approach on several language pairs. We conclude our work with some discussions in Section 4.
1

Under review as a conference paper at ICLR 2018

Output sequence

you really want to make the decision right

SWAN

Bi-directional RNN Soft reordering

sie wirklich wollen treffen die entscheidung richtig

Word embedding

Input sequence (a)

sie wollen die entscheidung wirklich richtig treffen
(b)

Figure 1: (a) The overall architecture of NPMT. (b) An illustration of using NPMT in GermanEnglish translation. Ideally, phrases in the source sentence (German) are first reordered. Given the new order, phrases can be translated one by one to the target phrases. These translated phrases then compose the target sentence (English). Phrase boundaries in the target language are not predefined, but automatically discovered by the model. No attention-based decoders are used here.

2 NEURAL PHRASE-BASED MACHINE TRANSLATION
We first give an overview of the proposed NMPT architecture and some related work on incorporating phrases into NMT. We then describe the two key building blocks in NPMT: 1) SWAN, and 2) the soft reordering layer which alleviates the monotonic alignment requirement of SWAN. In the context of machine translation, we use "segment" and "phrase" interchangeably.
2.1 THE OVERALL ARCHITECTURE OF NMPT
Figure 1(a) shows the overall architecture of NPMT. The input sequence is first turned into embedding representations and then they go through a (soft) reordering layer (described below in Section 2.3). We then pass these "reordered" activations to the bi-directional RNN layers, which are finally fed into the SWAN layer to directly output target language in terms of segments (or phrases). While it is possible to replace bi-directional RNN layers with other layers (Gehring et al., 2017), in this paper, we have only explored this particular setting to demonstrate our proposed idea.
There have been several works that propose different ways to incorporate phrases into attentionbased neural machine translation, such as Tang et al. (2016); Wang et al. (2017b); Dahlmann et al. (2017). These approaches typically use predefined phrases (obtained by external methods, e.g., phrase-based SMT) to guide or modify the existing attention-based decoder. The major difference from our approach is that, in NPMT, we do not use attention-based decoding mechanisms, and our phrase structures for the target language are automatically discovered from the training data. Another line of related work is the segment-to-segment neural transduction model (SSNT) (Yu et al., 2016), which shows promising results on a Chinese-to-English translation task under a noisy channel framework (Yu et al., 2017). In SSNT, the segments are implicit, and the monotonic alignments between the inputs and outputs are achieved using latent variables. The latent variables are marginalized out during training using dynamic programming.
2.2 MODELING PHRASES WITH SWAN
Here we review the SWAN model proposed in Wang et al. (2017a). SWAN defines a probability distribution for the output sequence given an input sequence. It models all valid output segmentations of the output sequence as well as the monotonic alignments between the output segments and
2

Under review as a conference paper at ICLR 2018
$

$

$$

$

Figure 2: Courtesy to Wang et al. (2017a). Symbol $ indicates the end of a segment. SWAN emits
one particular segmentation of y1:3 = (a1:5), where {a1 = {y1, $}, a2 = {$}, a3 = {$}, a4 = {y2, y3, $}, a5 = {$}}. Here x1 wakes (emitting segment a1) and x4 wakes (emitting segment a4) while x2, x3 and x5 sleep (emitting empty segments a2, a3 and a5 respectively).

the input sequence. Empty segments are allowed in the output segmentations. It does not make any assumption on the lengths of input or output sequence.
Assume input sequence is x1:T and output sequence is y1:T . Let Sy denote the set containing all valid segmentations of y1:T , with the constraint that the number of segments in a segmentation is the same as the input sequence length, T . Let at denote a segment or phrase in the target sequence. Empty segments are allowed to ensure that we can correctly align segment at to input element xt. Otherwise, we might not have a valid alignment for the input and output pair. See Figure 2 for an example of the emitted segmentation of y1:T . The probability of the sequence y1:T is defined as the sum of the probabilities of all the segmentations in Sy {a1:T : (a1:T ) = y1:T }, 1

p(y1:T |x1:T )

T
p(at|xt),
a1:T Sy t=1

(1)

where the p(at|xt) is the segment probability given input element xt, which is modeled using a recurrent neural network (RNN) with an additional softmax layer. (·) is the concatenation operator and the symbol $, end of a segment, is ignored in the concatenation operator (·). (An empty segment, which only contains $ will thus be ignored as well.) Since |Sy| is exponentially large, direct summation quickly becomes infeasible when T or T is not small. Instead, Wang et al. (2017a) developed an exact dynamic programming algorithm to tackle the computation challenges.2 The key
idea is that although the number of possible segmentations is exponentially large, the number of possible segments is polynomial--O(T 2). In other words, it is possible to first compute all possible segment probabilities, p(at|xt), at, xt, and then use dynamic programming to calculate the output sequence probability p(y1:T |x1:T ) in Eq. (1). The feasibility of using dynamic programming is due to a property of segmentations--a segmentation of a subsequence is also part of the segmentation
of the entire sequence. In practice, a maximum length for a segment at is enforced to reduce the computational complexity, since the length of useful segments is often not very long. Wang et al.
(2017a) also discussed a way to carry over information across segments using a separate RNN, which
we will not elaborate here. We refer the readers to the original paper for the algorithmic details.

SWAN defines a conditional probability for an output sequence given an input one. It can be used in many sequence-to-sequence tasks. In practice, a sequence encoder like a bi-directional RNN can be used to process the raw input sequence (like speech signals or source language) to obtain x1:T that is to be passed into SWAN for decoding. For example, Wang et al. (2017a) demonstrated the usefulness of SWAN in the context of speech recognition.

1If predefined phrase structure information is provided for the target language in advance, we can incorporate it into SWAN by restricting the size of Sy. We leave the exploration of this option as future work.
2The computational complexity of SWAN is still high even with the dynamic programming algorithm. This is the reason that it takes a longer time to train our method for larger datasets such as in WMT translation tasks (weeks for a moderate model size). In the meantime, we are actively looking into the algorithms that can significantly speed up SWAN.

3

Under review as a conference paper at ICLR 2018

Greedy decoding for SWAN is straightforward. We first note that p(at|xt) is modeled as an RNN with an additional softmax layer. Then for each xt in x1:T , we can use a left-to-right greedy decoding algorithm (Sutskever et al., 2014) for p(at|xt) to produce an output segment (possibly empty). We then concatenate these output segments to form the greedy decoding of the entire output sequence. See Wang et al. (2017a) for the algorithmic details of the beam search decoder.
We finally note that, in SWAN (thus in NPMT), only output segments are explicit; input segments are implicitly modeled by allowing empty segments in the output. This is conceptually different from the traditional phrase-based SMT where both inputs and outputs are phrases (or segments). We leave the option of exploring explicit input segments as future work.

2.3 LOCAL REORDERING OF INPUT SEQUENCES

SWAN assumes a monotonic alignment between the output segments and the input elements. For speech recognition experiments in Wang et al. (2017a), this is a reasonable assumption. However, for machine translation, this is usually too restrictive. In neural machine translation literature, attention mechanisms were proposed to address alignment problems (Bahdanau et al., 2015; Luong et al., 2015; Raffel et al., 2017; Vaswani et al., 2017). But it is not clear how to apply a similar attention mechanism to SWAN due to the use of segmentations for output sequences.
One may note that in NPMT, a bi-directional RNN encoder for the source language can partially mitigate the alignment issue for SWAN, since it can access every source word. However, from our empirical studies, it is not enough to obtain the best performance. Here we augment SWAN with a reordering layer that does (soft) local reordering of the input sequence. This new model leads to promising results on the IWSLT 2014 German-English/English-German, and IWSLT 2015 English-Vietnamese machine translation tasks. One additional advantage of using SWAN is that since SWAN does not use attention mechanisms, decoding can be much faster, as now we remove the need to query the entire input source for every output word (Raffel et al., 2017).
We now describe the details of the local reordering layer shown in Figure 3(a). Denote the input to the local reordering layer by e1:T and the output of this layer by h1:T . We compute ht as

2

ht = tanh

 wiT [et- ; . . . ; et; . . . ; et+ ] et-+i .

i=0

(2)

where (·) is the sigmoid function, and 2 + 1 is the local reordering window size. Notation [et- ; . . . ; et; . . . ; et+ ] is the concatenation of vectors et- , . . . , et, . . . , et+ . For i = 0, . . . , 2 , notation wi is the parameter for the gate function at position i of the input window. It decides the weight of et-+i through the gate  wiT [et- ; . . . ; et; . . . ; et+ ] . The final output ht is a weighted linear combination of the input elements, et- , . . . , et, . . . , et+ , in the window followed by a nonlinear transformation by the tanh(·) function.
Figure 3(b) illustrates how local reordering works. Here we want to (softly) select an input element from a window given all information available in this window. Suppose we have two adjacent windows, (e1, e2, e3) and (e2, e3, e4). If e3 gets the largest weight (e3 is picked) in the first window and e2 gets the largest weight (e2 is picked) in the second window, e2 and e3 are effectively reordered. Our layer is different from the attention mechanism (Bahdanau et al., 2015; Luong et al., 2015; Raffel et al., 2017; Vaswani et al., 2017) in following ways. First, we do not have a query to begin with as in standard attention mechanisms. Second, we do not normalize the weights for the input elements et- , . . . , et, . . . , et+ . This provides the reordering capability and can potentially turn off everything if needed. Third, the gate of any position i in the reordering window is determined by all input elements et- , . . . , et, . . . , et+ in the window. Finally, the layer performs locally similar to a convolutional layer and the positional information is encoded by a different parameter wi for each relative position i in the window. We provide a visualizing example of the reordering layer gates in Appendix A and an empirical comparison of different window sizes in Appendix B.
One related work to our proposed reordering layer is the Gated Linear Units (GLU) (Dauphin et al., 2017) which can control the information flow of the output of a traditional convolutional layer. But GLU does not have a mechanism to decide which input element from the convolutional window to choose. From our experiments, neither GLU nor traditional convolutional layer helped our NPMT.

4

Under review as a conference paper at ICLR 2018

ht h2 h3

t-2 t-1

t t+1t+2

et-2 et-1

et et+1 et+2 e1
(a)

e2 e3
(b)

e4

Figure 3: (a) Example of a local reordering layer of window size 5 ( = 2) to compute ht. Here t-2+i (wiT [et-2; et-1; et; et+1; et+2]), i = 0, . . . , 4, are the gates that decides how much information ht should accept from those elements from this input window. Note that all information available in this input window helps decides each gate. (b) An illustration of the reordering layer
that swaps information between e2 and e3 and contributes to h3 and h2, respectively.

3 EXPERIMENTS
In this section, we evaluate our model on the IWSLT 2014 German-English (Cettolo et al., 2014), IWSLT 2014 English-German, and IWSLT 2015 English-Vietnamese (Cettolo et al., 2015) machine translation tasks. We note that, in this paper, we limit the applications of our model to relatively small datasets to demonstrate the usefulness of our method. We plan to conduct more large scale experiments in future work.
3.1 IWSLT14 GERMAN-ENGLISH
We evaluate our model on the German-English machine translation track of the IWSLT 2014 evaluation campaign (Cettolo et al., 2014). The data comes from translated TED talks, and the dataset contains roughly 153K training sentences, 7K development sentences, and 7K test sentences. We use the same preprocessing and dataset splits as in Ranzato et al. (2015); Wiseman & Rush (2016); Bahdanau et al. (2017). The German and English vocabulary sizes are 32,010 and 22,823 respectively.
We report our IWSLT 2014 German-English experiments using one reordering layer with window size 7, two layers of bi-directional GRU encoder (Gated recurrent unit, Chung et al. (2014)) with 256 hidden units, and two layers of unidirectional GRU decoder with 512 hidden units. We add dropout with a rate of 0.5 in the GRU layer. We choose GRU since baselines for comparisons were using GRU. The maximum segment length is set to 6. Batch size is set as 32 (per GPU) and the Adam algorithm (Kingma & Ba, 2014) is used for optimization with an initial learning rate of 0.001. For decoding, we use greedy search and beam search with a beam size of 10. As reported in Maas et al. (2014); Bahdanau et al. (2017), we find that penalizing candidate sentences that are too short was required to obtain the best results. We add the middle term of Eq. (3) to encourage longer candidate sentences. All hyperparameters are chosen based on the development set. NPMT takes about 2­3 days to run to convergence (40 epochs) on a machine with four M40 GPUs. The results are summarized in Table 1. In addition to previous reported baselines in the literature, we also explored the best hyperparameter using the same model architecture (except the reordering layer) using sequence-to-sequence model with attention as reported as LL of Table 1.
NPMT achieves state-of-the-art results on this dataset as far as we know. Compared to the supervised sequence-to-sequence model, LL (Bahdanau et al., 2017), NPMT achieves 2.4 BLEU gain in the greedy setting and 2.25 BLEU gain using beam-search. Our results are also better than those from the actor-critic based methods in Bahdanau et al. (2017). But we note that our proposed method is orthogonal to the actor-critic method. So it is possible to further improve our results using the actor-critic method.
We also run the following two experiments to verify the sources of the gain. The first is to add a reordering layer to the original sequence-to-sequence model with attention, which gives us BLEU

5

Under review as a conference paper at ICLR 2018

MIXER (Ranzato et al., 2015) LL (Wiseman & Rush, 2016) BSO (Wiseman & Rush, 2016) LL (Bahdanau et al., 2017) LL
RF-C+LL (Bahdanau et al., 2017) AC+LL (Bahdanau et al., 2017)
NPMT (this paper) NPMT+LM (this paper)

BLEU Greedy Beam Search

20.73 22.53 23.83 25.82 26.17

21.83 23.87 25.48 27.56 27.61

27.70 27.49

28.30 28.53

28.57 ­

29.92 30.08

Table 1: Translation results on the IWSLT 2014 German-English test set. MIXER Ranzato et al. (2015) uses a convolutional encoder and simpler attention. LL (attention model with log likelihood) and BSO (beam search optimization) of Wiseman & Rush (2016), and LL, RF-C+LL, and AC+LL of Bahdanau et al. (2017) use a one-layer GRU encoder and decoder with attention. (RF-C+LL and AC+LL are different settings of actor-critic algorithms combined with LL.) LL stands for a well-tuned attention model with log likelihood with the same word embedding size, and encoder and decoder size as NPMT.

scores of 25.55 (greedy) and 26.91 (beam search). Since the attention mechanism and reordering layer capture similar information, adding the reordering layer to the sequence-to-sequence model with attention does not improve the performance. The second is to remove the reordering layer from NPMT, which gives us BLEU scores of 27.79 (greedy) and 29.28 (beam search). This shows that the reordering layer and SWAN are both important for the effectiveness of NPMT.

In greedy decoding, we can estimate the average segment length3 for the output. The average segment length is around 1.4­1.5, indicating phrases with more than one word are being decoded. Figure 4 shows an example of the input and decoding results with NPMT. We can observe phraselevel translation being captured by the model (e.g., "danke"  "thank you"). The model also knows when to sleep before outputting a phrase (e.g., "das"  "$"). We use the indexes of words in the source sentence to indicate where the output phrases are from. Table 2 shows some sampled examples. We can observe there are many informative segments in the decoding results, e.g., "tens of thousands of", "the best thing", "a little", etc. There are also mappings from phrase to phrase, word to phrases, and phrase to word in the examples. Following the analysis, we show the most frequent phrase mappings in Appendix C.

We also explore an option of adding a language-model score during beam search as the traditional statistical machine translation does. This option might not make much sense in attention-based approaches, since the decoder itself is usually a neural network language model. In SWAN, however, there is no language models directly involved in the segmentation modeling,4 and we find it useful to have an external language model during beam search. We use a 4th-order language model trained using the KenLM implementation (Heafield et al., 2013) for English target training data. So the final beam search score we use is

Q(y) = log p(y|x) + 1word_count(y) + 2 log plm(y),

(3)

where we empirically find that 1 = 1.2 and 2 = 0.2 give good performance, which are tuned on the development set. The results with the external language model are denoted by NPMT+LM in
Table 1. If no external language models are used, we set 2 = 0. This scoring function is similar to the one for speech recognition in Hannun et al. (2014).

3The average segment length is defined as the length of the output (excluding end of segment symbol $) divided by the number of segments (not counting the ones only containing $).
4In Wang et al. (2017a), SWAN does have an option to use a separate RNN that connects the segments, which can be seen as a language model. However, different from speech recognition experiments, we find in machine translation experiments, adding this separate RNN leads to a worse performance. We suspect this is because an RNN language model can be easier to learn than the segmentation structures and SWAN gets stuck in that local mode. This is further evidenced by the fact that the average segment length is much shorter with a separate RNN in SWAN.

6

Under review as a conference paper at ICLR 2018

thank you , but

the best thing is still coming

.

$$

Soft reordering + Bi-directional RNN

danke 1

, aber das beste 2345

kommt 6

noch . 78

Figure 4: An example of NPMT greedy decoding output for German-English translation. The example corresponds to the first example of Table 2. Note that for illustrating the input and output segments, we do not take into account of the behavior of the reordering layer and bi-directional RNN--the index mappings from source to target assumes monotonic alignments so some of them might be inaccurate.

source greedy decoding target ground truth
source greedy decoding target ground truth
source greedy decoding target ground truth
source
greedy decoding
target ground truth

1danke 2, 3aber 4das 5beste 6kommt 7noch 8. 1thank you · 2, · 3but · 5the best thing · 6is still coming · 8.
thanks . i haven 't come to the best part . 1sie 2ko¨nnen 3einen 4schalter 5dazwischen 6einfu¨gen 7und 8so 9haben 10sie 11einen 12kleinen 13UNK 14erstellt 15. 1you can put · 4a switch · 5in between · 7and · 8so · 10they created · 12a little · 13UNK 14.
you can put a knob in between and now you 've made a little UNK . 1sie 2wollen 3die 4entscheidung 5wirklich 6richtig 7treffen 8, 9wenn 10es 11fu¨r 12alle 13ewigkeit 14ist 15, 16richtig 17? 1you really want to make · 4the decision · 6right · 8, · 9if · 10it 's · 11for · 12all · 13eternity · 15, · 16right · 17?
you really want to get the decision right if it 's for all eternity , right ? 1es 2gibt 3zehntausende 4maschinen 5rund 6um 7die 8welt 9die 10kleine 11stu¨cke 12von 13dna 14herstellen 15ko¨nnen 16, 1730 18bis 1950 20buchstaben 21lang 22aber 23es 24ist 25ein 26UNK 27prozess 28, 29also 30je 31la¨nger 32man 33ein 34stu¨ck 35macht 36, 37umso 38mehr 39fehler 40passieren 41. 1there are · 3tens of thousands of · 4machines · 6around · 8the world · 9can make · 10little · 11pieces · 12of · 13dna · 16, · 1730 · 18to · 1950 · 20letters · 21long · 22, but · 23it 's · 26a more UNK · 27process · 28, · 29so · 31the longer · 32you make · 34a piece · 36, · 38the more · 39mistakes · 40happen · 41.
there are tens of thousands of machines around the world that make small pieces of dna
­ 30 to 50 letters - in length - and it 's a UNK process ,
so the longer you make the piece , the more errors there are .

Table 2: Examples of German-English translation outputs with their segmentations. We label the
indexes of the words in the source sentence and we use those indexes to indicate where the output segment is emitted. For example, in greedy decoding results, "iword1, . . . , wordm" denotes i-th word in the source sentence emits words word1, . . . , wordm during decoding (assuming monotonic alignments). The "·" represents the segment boundary in the target output. See Figure 4 for a
visualization of row 1 in this table.

3.2 IWSLT14 ENGLISH-GERMAN
We also evaluate our model on the opposition direction, English-German, which translates from a more segmented text to a more inflectional one. Following the setup in Section 3.1, we use the

7

Under review as a conference paper at ICLR 2018

same dataset with the opposite source and target languages. We use the same model architecture, optimization algorithm and beam search size as the German-English translation task. NPMT takes about 2­3 days to run to convergence (40 epochs) on a machine with four M40 GPUs.
Given there is no previous sequence-to-sequence attention model baseline for this setup, we create a strong one and tune hyperparameters on the development set. The results are shown in Table 3. Based on the development set, we set 1 = 1 and 2 = 0.15 in Eq. (3). Our model outperforms sequence-to-sequence model with attention by 2.46 BLEU and 2.49 BLEU in greedy and beam search cases. We can also use a 4th-order language model trained using the KenLM implementation for German target training data, which further improves the performance. Some sampled examples are shown in Table 4. Several informative segments/phrases can be found in the decoding results, e.g., "some time ago"  "vor enniger zeit".

Sequence-to-sequence with attention NPMT (this paper) NPMT+LM (this paper)

BLEU Greedy Beam Search

21.26 23.62
­

22.59 25.08 25.36

Table 3: Translation results on the IWSLT 2014 English-German test set.

source greedy decoding target ground truth
source greedy decoding target ground truth
source
greedy decoding
target ground truth
source
greedy decoding
target ground truth

1how 2would 3you 4guys 5describe 6your 7brand 8? 1wie · 2wu¨rdet · 3sie · 6ihre marke · 8beschreiben ?
wie wu¨rdet ihr eure marke beschreiben ? 1if 2the 3museum 4has 5given 6us 7the 8image 9, 10you 11click 12on 13it 14. 1wenn · 2das museum · 6uns · 7das bild · 9gegeben hat ,· 10klicken sie · 13darauf · 14.
wenn das museum uns das bild gegeben hat , klicken sie darauf . 1they 2are 3frustrated 4as 5hell 6with 7it 8, 9but 10they 11're 12not 13complaining 14about 15it 16, 17they 18're 19fixing 20it 21. 1sie sind · 3frustriert · 8, · 9aber · 10sie UNK sich · 12nicht · 15daru¨ber · 16, · 17sie reparieren · 20es · 21.
sie sie sind fu¨rchterlich frustriert mit ihr , aber sie beschweren sich nicht daru¨ber ,
sie reparieren sie . ? 1now 2some 3time 4ago 5, 6if 7you 8wanted 9to 10win 11a 12formula 131 14race 15, 16you 17take 18a 19budget 20, 21and 22you 23bet 24your 25budget 26on 27a 28good 29driver 30and 31a 32good 33car 34. 2vor einiger zeit · 6wenn · 7man · 11eine formel · 15gewinnen will , · 18ein budget · 21und · 23 , dass · 24ihr budget · 27auf einem guten · 29fahrer · 30und · 31ein gutes · 33auto · 34.
vor einiger zeit war es so , dass wenn sie ein formel 1 rennen gewinnen wollten ,
dann nahmen sie ihr budget und setzten ihr geld auf einen guten fahrer und ein gutes auto .

Table 4: Examples of English-German translation outputs with their segmentations. The meanings of the superscript indexes and the "·" symbol are the same as those in Table 2.

3.3 IWSLT15 ENGLISH-VIETNAMESE
In this section, we evaluate our model on the IWSLT 2015 English to Vietnamese machine translation task. The data is from translated TED talks, and the dataset contains roughly 133K training sentence pairs provided by the IWSLT 2015 Evaluation Campaign (Cettolo et al., 2015). Following the same preprocessing steps in Luong & Manning (2015); Raffel et al. (2017), we use the TED tst2012 (1553 sentences) as a validation set for hyperparameter tuning and TED tst2013 (1268 sentences) as a test set. The Vietnamese and English vocabulary sizes are 7,709 and 17,191 respectively.
We use one reordering layer with window size 7, two layers of bi-directional LSTM (Long shortterm memory, Hochreiter & Schmidhuber (1997)) encoder with 512 hidden units, and three layers of unidirectional LSTM decoder with 512 hidden units. We add dropout with a rate of 0.4 in the LSTM layer. We choose LSTM since baselines for comparisons were using LSTM. The maximum
8

Under review as a conference paper at ICLR 2018

segment length is set to 7. Batch size is set as 48 (per GPU) and the Adam algorithm Kingma & Ba (2014) is used for optimization with an initial learning rate of 0.001. For decoding, we use greedy decoding and beam search with a beam size of 10. The results are shown in Table 5. Based on the development set, we set 1 = 0.7 and 2 = 0.15 in Eq. (3). NPMT takes about one day to run to convergence (15 epochs) on a machine with 4 M40 GPUs. Our model outperforms sequence-tosequence model with attention by 1.41 BLEU and 1.59 BLEU in greedy and beam search cases. We also use a 4th-order language model trained using the KenLM implementation for Vietnamese target training data, which further improves the BLEU score. Note that our reordering layer relaxes the monotonic assumption as in Raffel et al. (2017) and is able to decode in linear time. Empirically we outperform models with monotonic attention. Table 6 shows some sampled examples.

Hard monotonic (Raffel et al., 2017) Luong & Manning (2015) Sequence-to-sequence model with attention NPMT (this paper) NPMT+LM (this paper)

BLEU Greedy Beam Search

23.00 -
25.50 26.91
­

23.30 26.10 27.69 28.07

Table 5: Translation results on the IWSLT 2015 English-Vietnamese tst2013 test set. The result of
the sequence-to-sequence model with attention is obtained from an open source model provided by the authors.6

source greedy decoding target ground truth
source greedy decoding
target ground truth source
greedy decoding
target ground truth source
greedy decoding
target ground truth

1And 2I 3figured 4, 5this 6has 7to 8stop 9. 1Và · 2tôi · 3nhn ra rng · 4, · 5iu này · 6phi· 8dng li 9.
Và tôi nhn ra rng iu ó phi chm dt . 1So 2great 3progress 4and 5treatment 6has 7been 8made 9over 10the 11years 12. 1Vì vy , · 2tin b· 4và · 5iu tr · 6ã · 7c · 8to ra · 9trong · 10nhng · 11nm · 12.
Trong sut nhng nm qua ã có s tin b to ln trong quá trình iu tr . 1The 2passion 3that 4the 5person 6has 7for 8her 9own 10growth 11is 12the 13most 14 important 15 thing 16. 1Nim am mê · 3rng · 5ngi · 6 có · 7 cho · 8s phát trin · 10ca cô y · 11là · 13iu · 14quan trng · 15nht · 16.
Cái khát vng ca ngi ph n có cho s phát trin ca bn thân là th quan trng nht . 1We 2have 3eight 4species 5of 6UNK 7that 8occur 9 in 10Kenya 11, 12of 13which 14six 15are 16highly 17threatened 18with 19 extinction 20. 1Chúng ta · 2có · 38 · 4loài · 6 UNK · 8xy ra · 9 · 10Kenya · 11, · 146 · 17b e do · 19tuyt chng · 20.
Chúng ta có 8 loài kn kn xut hin ti Kenya , trong ó có 6 loài b e do vi nguy
c tuyt chng cao .

Table 6: Examples of English-Vietnamese translation outputs with their segmentations. The meanings of the superscript indexes and the "·" symbol are the same as those in Table 2.

4 CONCLUSION
We proposed NPMT, a neural phrase-based machine translation system that models phrase structures in the target language using SWAN. We also introduced a local reordering layer to mitigate the monotonic alignment requirement in SWAN. Our experimental results showed promising results on IWSLT 2014 German-English, English-German, and IWSLT 2015 English-Vietnamese machine translation tasks. The results suggest that NPMT can potentially be extended to explore the structures in other challenging sequence-to-sequence problems. In future work, we will explore two directions: 1) speed up NPMT and apply it to larger datasets and more language pairs; 2) investigate how to learn input and output phrases simultaneously.
6https://github.com/tensorflow/nmt

9

Under review as a conference paper at ICLR 2018
REFERENCES
Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. Neural machine translation by jointly learning to align and translate. In International Conference on Learning Representations, 2015.
Dzmitry Bahdanau, Philemon Brakel, Kelvin Xu, Anirudh Goyal, Ryan Lowe, Joelle Pineau, Aaron C. Courville, and Yoshua Bengio. An actor-critic algorithm for sequence prediction. In International Conference on Learning Representations, 2017.
Mauro Cettolo, Jan Niehues, Sebastian Stu¨ker, Luisa Bentivogli, and Marcello Federico. Report on the 11th IWSLT evaluation campaign, IWSLT 2014. In Proceedings of IWSLT, 2014.
Mauro Cettolo, Jan Niehues, Sebastian Stu¨ker, Luisa Bentivogli, Roldano Cattoni, and Marcello Federico. The IWSLT 2015 evaluation campaign. In International Conference on Spoken Language, 2015.
Junyoung Chung, Caglar Gulcehre, KyungHyun Cho, and Yoshua Bengio. Empirical evaluation of gated recurrent neural networks on sequence modeling. arXiv preprint arXiv:1412.3555, 2014.
Leonard Dahlmann, Evgeny Matusov, Pavel Petrushkov, and Shahram Khadivi. Neural machine translation leveraging phrase-based models in a hybrid search. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing, pp. 1422­1431, 2017.
Yann N Dauphin, Angela Fan, Michael Auli, and David Grangier. Language modeling with gated convolutional networks. In International Conference on Machine Learning (ICML), 2017.
Jonas Gehring, Michael Auli, David Grangier, Denis Yarats, and Yann N Dauphin. Convolutional sequence to sequence learning. In ICML, 2017.
Awni Hannun, Carl Case, Jared Casper, Bryan Catanzaro, Greg Diamos, Erich Elsen, Ryan Prenger, Sanjeev Satheesh, Shubho Sengupta, Adam Coates, et al. Deep speech: Scaling up end-to-end speech recognition. arXiv preprint arXiv:1412.5567, 2014.
Kenneth Heafield, Ivan Pouzyrevsky, Jonathan H. Clark, and Philipp Koehn. Scalable modified Kneser-Ney language model estimation. In Proceedings of the 51th Annual Meeting of the Association for Computational Linguistics: Short Papers-Volume 2, pp. 690­696, 2013.
Sepp Hochreiter and Ju¨rgen Schmidhuber. Long short-term memory. Neural Computation, 9(8): 1735­1780, 1997.
Diederik Kingma and Jimmy Ba. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980, 2014.
Philipp Koehn. Statistical Machine Translation. Cambridge University Press, 2009.
Philipp Koehn, Franz Josef Och, and Daniel Marcu. Statistical phrase-based translation. In Proceedings of the 2003 Conference of the North American Chapter of the Association for Computational Linguistics on Human Language Technology-Volume 1, pp. 48­54, 2003.
Adam Lopez. Statistical machine translation. ACM Computing Surveys (CSUR), 40(3):8, 2008.
Minh-Thang Luong and Christopher D Manning. Stanford neural machine translation systems for spoken language domains. In Proceedings of the International Workshop on Spoken Language Translation, 2015.
Minh-Thang Luong, Hieu Pham, and Christopher D Manning. Effective approaches to attentionbased neural machine translation. arXiv preprint arXiv:1508.04025, 2015.
Andrew L. Maas, Awni Y. Hannun, Daniel Jurafsky, and Andrew Y. Ng. First-pass large vocabulary continuous speech recognition using bi-directional recurrent DNNs. CoRR, abs/1408.2873, 2014.
Kishore Papineni, Salim Roukos, Todd Ward, and Wei-Jing Zhu. BLEU: a method for automatic evaluation of machine translation. In Proceedings of the 40th Annual Meeting on Association for Computational Linguistics, pp. 311­318, 2002.
10

Under review as a conference paper at ICLR 2018
Colin Raffel, Thang Luong, Peter J Liu, Ron J Weiss, and Douglas Eck. Online and linear-time attention by enforcing monotonic alignments. In International Conference on Machine Learning (ICML), 2017.
Marc'Aurelio Ranzato, Sumit Chopra, Michael Auli, and Wojciech Zaremba. Sequence level training with recurrent neural networks. CoRR, abs/1511.06732, 2015.
Ilya Sutskever, Oriol Vinyals, and Quoc V Le. Sequence to sequence learning with neural networks. In Advances in Neural Information Processing Systems, pp. 3104­3112, 2014.
Yaohua Tang, Fandong Meng, Zhengdong Lu, Hang Li, and Philip LH Yu. Neural machine translation with external phrase memory. arXiv preprint arXiv:1606.01792, 2016.
Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Lukasz Kaiser, and Illia Polosukhin. Attention is all you need. arXiv preprint arXiv:1706.03762, 2017.
Chong Wang, Yining Wang, Po-Sen Huang, Abdelrahman Mohamed, Dengyong Zhou, and Li Deng. Sequence modeling via segmentations. In International Conference on Machine Learning (ICML), 2017a.
Xing Wang, Zhaopeng Tu, Deyi Xiong, and Min Zhang. Translating phrases in neural machine translation. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing, pp. 1432­1442. Association for Computational Linguistics, 2017b.
Sam Wiseman and Alexander M. Rush. Sequence-to-sequence learning as beam-search optimization. CoRR, abs/1606.02960, 2016.
Yonghui Wu, Mike Schuster, Zhifeng Chen, Quoc V Le, Mohammad Norouzi, Wolfgang Macherey, Maxim Krikun, Yuan Cao, Qin Gao, Klaus Macherey, et al. Google's neural machine translation system: Bridging the gap between human and machine translation. arXiv preprint arXiv:1609.08144, 2016.
Lei Yu, Jan Buys, and Phil Blunsom. Online segment to segment neural transduction. In Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing, pp. 1307­1316, 2016.
Lei Yu, Phil Blunsom, Chris Dyer, Edward Grefenstette, and Tomas Kocisky. The neural noisy channel. In International Conference on Learning Representations, 2017.
Jie Zhou, Ying Cao, Xuguang Wang, Peng Li, and Wei Xu. Deep recurrent models with fast-forward connections for neural machine translation. Transactions of the Association for Computational Linguistics, 4:371­383, 2016.
11

Under review as a conference paper at ICLR 2018

A REORDERING LAYER ANALYSIS

To further understand the behavior of the reordering layer, we examine the values of the gate  wiT [et- ; . . . ; et; . . . ; et+ ] in Eq. (2). We study the NPMT English-German model in Section 3.2. In Figure 5, we show an example that translates from "can you translate it ?" to "ko¨nnen man es u¨bersetzen ?", where the mapping between words are as follows: "can  ko¨nnen", "you  man", "translate  u¨bersetzen", "it  es" and "?  ?". Note that the example needs to be
reordered from "translate it" to "es u¨bersetzen". Each row of Figure 5 represents a window of size
7 that is centered at a source sentence word. The values in the matrix represent the gate values for
the corresponding words. The gate values will later be multiplied with the embedding et-+i of Eq. (2) and contribute to the hidden vector ht. The y-axis represents the word/phrases emitted from the corresponding position. We can observe that the gates mostly focus on the central word since
the first part of the sentence only requires monotonic alignment. Interestingly, the model outputs
"$" (empty) when the model has the word "translate" in the center of the window. Then, the model
outputs "es" when the model encounters "it". Finally, in the last window (top row), the model not
only has a large gate value to the center input "?", but the model also has a relatively large gate value
to the word "translate" in order to output the translation "u¨bersetzen ?". This shows an example of
the reordering effect achieved by using the gating mechanism of the reordering layer.

Visualizing Reordering Gates
übersetzen ? 0 0 0 0 0.0031 0.0343 0.0005 0.2644 0.0042 0.0073 0.0066

0.28

es 0 0 0 0.0004 0.0002 0.0020 0.2728 0.0045 0.0021 0.0012 0

0.24 0.20

Hypothesis

$0

0 0.0004 0.0003 0.0009 0.3147 0.0012 0.0002 0.0009 0

0

0.16

man 0 0.0004 0.0002 0.0036 0.2732 0.0084 0.0018 0.0003 0 0 0

0.12 0.08

können 0.0040 0.0024 0.0130 0.2432 0.0092 0.0119 0.0043 <pad> <pad> <pad> can yoSuourtcreanSselantteenceit

0000
? <pad> <pad> <pad>

0.04 0.00

Figure 5: Visualizing reordering gates in the NPMT English-German translation model.

B EFFECT OF WINDOW SIZES IN THE REORDERING LAYER
In this section, we examine the effect of window sizes in the reordering layer. Following the setup in Section 3.2, we evaluate the performance of different window sizes on the IWSLT 2014 EnglishGerman translation task. Table 7 summarizes the results. We can observe that the performance reaches the peak with a windows size of 7. With a window size of 5, the performance drops 0.88 BLEU in greedy decoding and 0.72 BLEU using beam search. It suggests that the context window is not large enough to properly perform reordering. When the window sizes are 9 and 11, we do not observe further improvements. It might be because the translation between English and German mostly requires local word reordering.
C PHRASE MAPPING EXAMPLES
Following the examples of Table 2, we analyze the decoding results on the test set of the GermanEnglish translation task. Given we do not have explicit input segments in NPMT, we assume input words that emit "$" symbol are within the same group as the next non-'$' word. For example, in Figure 4, input words "das beste" are considered as an input segment. We then can aggregate all the input, output segments (phrases) and sort them based on the frequency. Tables 8 and 9 show the most-frequent input, output phrase mappings.
12

Under review as a conference paper at ICLR 2018

Window Size
5 7 9 11

BLEU Greedy Beam Search

22.74 23.62 23.11 23.12

24.36 25.08 24.68 24.65

Table 7: Analyze the effect of reordering layer window sizes in translation results on the IWSLT 2014 English-German test set.

Table 8: German-English phrase mapping results. We show the top 10 input, output phrase mappings in five categories ("One" stands for single word and "Many" stands for multiple words.). In the last column, Many  Many, we remove the phrases with the "UNK" word as the "UNK" appears often.

One  One ,, .. und  and UNK  UNK aber  but "" ist  is der  of von  of mit  with

One  Many es  it 's UNK  the UNK und  , and das  this is das,  that 's UNK  a UNK ich  i think es  it was dies  this is es  there 's

Many  One , dass  that in der  in UNK .  . UNK ,  , , die  that ist .  . in den  in ist ,  , sind .  . , wenn  if

Many  Many die UNK  the UNK der UNK  the UNK ein UNK  a UNK das UNK  the UNK eine UNK  a UNK in UNK  in UNK den UNK  the UNK wissen sie  you know in diesem  in this dem UNK  the UNK

Many  Many wissen sie  you know in diesem  in this die welt  the world ist es  it 's ".." ein paar  a few gibt es  there 's der welt  the world die frage  the question haben wir  we have

Table 9: German-English longer phrase mapping results. We show the top 5 input, output phrase mappings for two categories: input and output phrases with three words, and input and output phrases with four words.

Phrases with 3 words auf der ganzen  all over the gibt eine menge  a lot of dann hat er he doesn 't have , die man  you can do das ko¨nnen wir  we can do that

Phrases with 4 words auf der ganzen  a little bit of weiß nicht , was  what 's going to be tun , das wir  we can 't do tat , das ich  i didn 't do zu verbessern , die  that can be done

13

