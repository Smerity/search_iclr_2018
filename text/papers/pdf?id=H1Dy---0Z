Under review as a conference paper at ICLR 2018
DISTRIBUTED PRIORITIZED EXPERIENCE REPLAY
Anonymous authors Paper under double-blind review
ABSTRACT
We propose a distributed architecture for deep reinforcement learning at scale, that enables agents to learn effectively from orders of magnitude more data than previously possible. The algorithm decouples acting from learning: the actors interact with their own instances of the environment by selecting actions according to a shared neural network, and accumulate the resulting experience in a shared experience replay memory; the learner replays samples of experience and updates the neural network. The architecture relies on prioritized experience replay to focus only on the most significant data generated by the actors. Our architecture substantially improves the state of the art on the Arcade Learning Environment, achieving better final performance in a fraction of the wall-clock training time.
1 INTRODUCTION
A broad trend in deep learning is that combining more computation (Dean et al., 2012) with more powerful models (Kaiser et al., 2017) and larger datasets (Deng et al., 2009) yields more impressive results. It is reasonable to hope that a similar principle holds for deep reinforcement learning. There are a growing number of examples to justify this optimism: effective use of greater computational resources has been a critical factor in the success of such algorithms as Gorila (Nair et al., 2015), A3C (Mnih et al., 2016), GPU Advantage Actor Critic (Babaeizadeh et al., 2017), Distributed PPO (Heess et al., 2017) and AlphaGo (Silver et al., 2016). Deep learning frameworks such as TensorFlow (Abadi et al., 2016) support distributed training, making large scale machine learning systems easier to implement and deploy. Despite this, much current research in deep reinforcement learning concerns itself with improving performance within the computational budget of a single machine, and the question of how to best harness more resources is comparatively underexplored. In this paper we describe an approach to scaling up deep reinforcement learning by generating more data and selecting from it in a prioritized fashion (Schaul et al., 2016). Standard approaches to distributed training of neural networks focus on parallelizing the computation of gradients, to more rapidly optimize the parameters (Dean et al., 2012). In contrast, we distribute the generation and selection of experience data, and find that this alone suffices to improve results. This is complementary to distributing gradient computation, and the two approaches can be combined, but in this work we focus purely on data-generation. We use this distributed architecture to scale up variants of Deep Q-Networks (DQN) and Deep Deterministic Policy Gradient (DDPG), and we evaluate these on the Arcade Learning Environment benchmark (Bellemare et al., 2013), and on a range of continuous control tasks. Our architecture achieves a new state of the art performance on Atari games, using a fraction of the wall-clock time compared to the previous state of the art, and without per-game hyperparameter tuning. We empirically investigate the scalability of our framework, analysing how prioritization affects performance as we increase the number of data-generating workers. Our experiments include an analysis of factors such as the replay capacity, the recency of the experience, and the use of different data-generating policies for different workers. Finally, we discuss implications for deep reinforcement learning agents that may apply beyond our distributed framework.
1

Under review as a conference paper at ICLR 2018
2 BACKGROUND
Distributed Stochastic Gradient Descent Distributed stochastic gradient descent is widely used in supervised learning to speed up training of deep neural networks, by parallelizing the computation of the gradients used to update their parameters. The resulting parameter updates may be applied synchronously (Krizhevsky, 2014) or asynchronously (Dean et al., 2012). Both approaches have proven effective and are an increasingly standard part of the deep learning toolbox. Inspired by this, Nair et al. (2015) applied distributed asynchronous parameter updates and distributed data generation to deep reinforcement learning. Asynchronous parameter updates and parallel data generation have also been successfully used within a single-machine, in a multi-threaded rather than a distributed context (Mnih et al., 2016). GPU Asynchronous Actor-Critic (GA3C; Babaeizadeh et al., 2017) and Parallel Advantage Actor-Critic (PAAC; Clemente et al., 2017) adapt this approach to make efficient use of GPUs.
Distributed Importance Sampling A complementary family of techniques for speeding up training is based on variance reduction by means of importance sampling (cf. Hastings, 1970). This has been shown to be useful in the context of neural networks (Hinton, 2007). Sampling non-uniformly from a dataset and weighting updates according to the sampling probability in order to counteract the bias thereby introduced can increase the speed of convergence by reducing the variance of the gradients. One way of doing this is to select samples with probability proportional to the L2 norm of the corresponding gradients. In supervised learning, this approach has been successfully extended to the distributed setting (Alain et al., 2015). An alternative is to rank samples according to their latest known loss value and make the sampling probability a function of the rank rather than of the loss itself (Loshchilov & Hutter, 2015).
Prioritized Experience Replay Experience replay (Lin, 1992) has long been used in reinforcement learning to improve data efficiency. It is particularly useful when training neural network function approximators with stochastic gradient descent algorithms, as in Neural Fitted Q-Iteration (Riedmiller, 2005) and Deep Q-Learning (Mnih et al., 2015). Experience replay may also help to prevent overfitting by allowing the agent to learn from data generated by previous versions of the policy. Prioritized experience replay (Schaul et al., 2016) extends classic prioritized sweeping ideas (Moore & Atkeson, 1993) to work with deep neural network function approximators. The approach is strongly related to the importance sampling techniques discussed in the previous section, but using a more general class of biased sampling procedures that focus learning on the most `surprising' experiences. Biased sampling can be particularly helpful in reinforcement learning, since the reward signal may be sparse and the data distribution depends on the agent's policy. As a result, prioritized experience replay is used in many agents, such as Prioritized Dueling DQN (Wang et al., 2016), UNREAL (Jaderberg et al., 2017), DQfD (Hester et al., 2017), and Rainbow (Hessel et al., 2017). In an ablation study conducted to investigate the relative importance of several algorithmic ingredients (Hessel et al., 2017), prioritization was found to be the most important ingredient contributing to the agent's performance.
3 OUR CONTRIBUTION: DISTRIBUTED PRIORITIZED EXPERIENCE REPLAY
In this paper we extend prioritized experience replay to the distributed setting and show that this is a highly scalable approach to deep reinforcement learning. We introduce a few key modifications that enable this scalability, and we refer to our approach as Ape-X.
As in Gorila (Nair et al., 2015), we decompose the standard deep reinforcement learning algorithm into two parts, which run concurrently with no high-level synchronization. The first part consists of stepping through an environment, evaluating a policy implemented as a deep neural network, and storing the observed data in a replay memory. We refer to this as acting. The second part consists of sampling batches of data from the memory to update the policy parameters. We term this learning.
In principle, both acting and learning may be distributed across multiple workers. In our experiments, hundreds of actors run on CPUs to generate data, and a single learner running on a GPU samples the most useful experiences. Pseudocode for the actors and learners is shown in Algorithms 1 and 2. Updated network parameters are periodically communicated to the actors from the learner.
2

Under review as a conference paper at ICLR 2018

Learner
Network
Network parameters

Sampled experience Updated priorities
Actor
Network Environment

Replay
Experiences
Initial priorities Generated experience

Figure 1: The Ape-X architecture in a nutshell: multiple actors, each with its own instance of the environment, generate experience, add it to a shared experience replay memory, and compute initial priorities for the data. The (single) learner samples from this memory and updates the network and the priorities of the experience in the memory. The actors' networks are periodically updated with the latest network parameters from the learner.

Algorithm 1 Actor

1: procedure ACTOR(B, T )

Run agent in environment instance, storing experiences.

2: 0  LEARNER.PARAMETERS( )

Remote call to obtain latest network parameters.

3: s0  ENVIRONMENT.INITIALIZE( )

Get initial state from environment.

4: for t = 1 to T do

5: at-1  (st-1)

Select an action using the current policy.

6: (rt, t, st)  ENVIRONMENT.STEP(at-1)

Apply the action in the environment.

7: LOCALBUFFER.ADD((st-1, at-1, rt, t))

Add data to local buffer.

8: if LOCALBUFFER.SIZE( )  B then In a background thread, periodically send data to replay.

9:

  LOCALBUFFER.GET(B)

Get buffered data (e.g. batch of multi-step transitions).

10: p  COMPUTEPRIORITIES( ) Calculate priorities for experience (e.g. absolute TD error).

11: REPLAY.ADD(, p)

Remote call to add experience to replay memory.

12: end if

13: PERIODICALLY(t  LEARNER.PARAMETERS())

Obtain latest network parameters.

14: end for

15: end procedure

Algorithm 2 Learner

1: procedure LEARNER(T )

Update network using batches sampled from memory.

2: 0  INITIALIZENETWORK( )

3: for t = 1 to T do

Update the parameters T times.

4: id,   REPLAY.SAMPLE( ) Sample a prioritized batch of transitions (in a background thread).

5: lt  COMPUTELOSS( ; t)

Apply learning rule; e.g. double Q-learning or DDPG

6: t+1  UPDATEPARAMETERS(lt; t)

7: p  COMPUTEPRIORITIES( ) Calculate priorities for experience, (e.g. absolute TD error).

8: REPLAY.SETPRIORITY(id, p)

Remote call to update priorities.

9:

PERIODICALLY(REPLAY.REMOVETOFIT())

Remove old experience from replay memory.

10: end for

11: end procedure

In contrast to Nair et al. (2015), we use a shared, centralized replay memory, and instead of sampling uniformly we prioritize to sample the most useful data more often. Since priorities are shared, high priority data discovered by any actor can benefit the whole system. Priorities can be defined in various ways, depending on the learning algorithm; two instances are described in the next sections.
In Prioritized DQN (Schaul et al., 2016) priorities for new transitions were initialized to the maximum priority seen so far, and only updated once they were sampled. This does not scale well: due to the large number of actors in our architecture, waiting for the learner to update priorities would result in a myopic focus on the most recent data, which has maximum priority by construction. Instead, we take advantage of the computation the actors in Ape-X are already doing to evaluate their local copies of the policy, by making them also compute suitable priorities for new transitions online. This ensures that data entering the replay has more accurate priorities, at no extra cost.
3

Under review as a conference paper at ICLR 2018

Sharing experiences has certain advantages compared to sharing gradients. Low latency communication is not as important as in distributed SGD, because experience data becomes outdated less rapidly than gradients, provided the learning algorithm is robust to off-policy data. Across the system, we take advantage of this by batching all communications with the centralized replay, increasing the efficiency and throughput at the cost of some latency. With this approach it is even possible for actors and learners to run in different data-centers without limiting performance.
Finally, by learning off-policy (cf. Sutton & Barto, 1998; 2017), we can further take advantage of Ape-X's ability to combine data from many distributed actors, by giving the different actors different exploration policies, broadening the diversity of the experience they jointly encounter. As we will see in the results, this can be sufficient to make progress on difficult exploration problems.

3.1 APE-X DQN

The general framework we have described may be combined with different learning algorithms. First, we combined it with a variant of DQN (Mnih et al., 2015) with some of the components of Rainbow (Hessel et al., 2017). More specifically, we used double Q-learning (van Hasselt, 2010; van Hasselt et al., 2016) with multi-step bootstrap targets (cf. Sutton, 1988; Sutton & Barto, 1998; 2017; Mnih et al., 2016) as the learning algorithm, and a dueling network architecture (Wang et al., 2016) as the function approximator q(·, ·, ).

This

results

in

computing

for

all

elements

in

the

batch

the

loss

lt()

=

1 2

(Gt

-

q(St, At, ))2

with

double-Q bootstrap value

Gt = Rt+1 + Rt+2 + . . . + n-1Rt+n + n q(St+n, argmax q(St+n, a, ), -) ,
a

multi-step return

where t is a time index for an experience sampled from the replay starting with state St and action At, and - denotes parameters of the target network (Mnih et al., 2015), a slow moving copy of the online parameters. Multi-step returns are truncated if the episode ends in fewer than n steps.

In principle, Q-learning variants are off-policy methods, so we are free to choose the policies we use to generate data. However, in practice, the choice of behaviour policy does affect both exploration and the quality of function approximation; furthermore we are using a multi-step return. In Ape-X DQN, each actor executes a different policy. This allows experience to be generated from a variety of strategies, relying on the prioritization mechanism to pick out the most effective experiences. In our experiments, the actors use -greedy policies with different values of . Low policies allow exploring deeper in the environment, while high policies prevent over-specialization.

3.2 APE-X DPG

To test the generality of the framework we also combined it with a continuous-action policy gradient system based on DDPG (Lillicrap et al., 2016), an implementation of deterministic policy gradients Silver et al. (2014) also similar to older methods (Werbos, 1990; Prokhorov & Wunsch, 1997), and tested it on a selection of continuous control tasks.

The Ape-X DPG setup is similar to Ape-X DQN, but the actor's policy is now represented explic-

itly by a separate policy network, in addition to the Q-network. The two networks are optimized

separately, by minimizing different losses on the sampled experience. We denote the policy and

Q-network parameters by  and  respectively, and adopt the same convention as above to denote

target networks. The Q-network outputs an action-value estimate q(s, a, ) for a given state s, and

multi-dimensional action a  Rm. It is updated using temporal-difference learning with a multi-step

bootstrap

target.

The

Q-network

loss

can

be

written

as

lt()

=

1 2

(Gt

-

q(St, At, ))2,

where

Gt = Rt+1 + Rt+2 + . . . + n-1Rt+n + nq(St+n, (St+n, -), -) .

multi-step return

The policy network outputs an action At = (St, )  Rm. The policy parameters are updated using policy gradient ascent on the estimated Q-value, using gradient q(St, (St, ), ) -- note

4

Under review as a conference paper at ICLR 2018

Human-normalized Score (Median Over 57 Games)

450% 400% 350%

Ape-X DQN (120hrs) Ape-X DQN (70hrs) Ape-X DQN (20hrs)

300%

250% 200% 150%

Rainbow
C51 Prioritized DQN

100% 50%
0

Gorila

DQN

50 100 150 200 250 300 Training Time (Hours)

Episode Return (Mean)

Episode Return (Mean)

Episode Return (Mean)

50K Beam Rider 40K 30K 20K 10K
0

1K Breakout 800 600 400 200
0

Pong 20 10 0 -10 -20

40K Qbert 32K 24K 16K 8K
0

160K

Seaquest

120K

80K

40K

0 0 2 4 6 8 10 Training Time (Hours)

30K Space Invaders 24K 18K 12K 6K
0 0 2 4 6 8 10 Training Time (Hours)

Figure 2: Left: Atari results aggregated across 57 games, evaluated from random no-op starts. Right: Atari training curves for selected games, against baselines. Blue: Ape-X DQN with 360 actors; Orange: A3C; Red: Rainbow; Purple: DQN. See appendix for longer runs over all games.

that this depends on the policy parameters  only through the action At = (St, ) that is input to the critic network. Further details of the Ape-X DPG algorithm are available in the appendix.

4 EXPERIMENTS

4.1 ATARI

In our first set of experiments we evaluate Ape-X DQN on Atari, and show state of the art results on this standard reinforcement learning benchmark. We use 360 actor machines (each using one CPU core) to feed data into the replay memory as fast as they can generate it; approximately 139 frames per second (FPS) each, for a total of 50K FPS, which corresponds to 12.5K transitions (because of a fixed action repeat of 4). The actors batch experience data locally before sending it to the replay: up to 100 transitions may be buffered at a time, which are then sent asynchronously in batches of B = 50. The learner asynchronously prefetches up to 16 batches of 512 transitions, and computes updates for 19 such batches each second, meaning that gradients are computed for 9.7K transitions per second on average. To reduce memory and bandwidth requirements, observation data is compressed using a PNG codec when sent and when stored in the replay. The learner decompresses data as it prefetches it, in parallel with computing and applying gradients. The learner also asynchronously handles any requests for parameters from actors.

Actors copy the network parameters from the learner every 400 frames (2.8 seconds). Each actor

i  {0, ..., N - 1} executes an

i-greedy policy where

i=

1+

i N



with

= 0.4,  = 8. Each i is

held constant throughout training. The episode length is limited to 50000 frames during training.

The capacity of the shared experience replay memory is soft-limited to 2 million transitions: adding new data is always permitted, to not slow down the actors, but every 100 learning steps any excess data above this capacity threshold is removed en masse, in FIFO order. The median actual size of the memory is 2035050. Data is sampled according to proportional prioritization, with a priority exponent of 0.6 and an importance sampling exponent set to 0.4.

In Figure 2, on the left, we compare the median human normalized score across all 57 games to several baselines: DQN, Prioritized DQN, Distributional DQN (Bellemare et al., 2017), Rainbow, and Gorila. In all cases the performance is measured at the end of training under the no-op starts testing regime (Mnih et al., 2015). On the right, we show initial learning curves (taken from the greediest actor) for a selection of 6 games (full learning curves for all games are in the appendix).

5

Under review as a conference paper at ICLR 2018

Algorithm
Ape-X DQN Rainbow Distributional (C51) A3C Prioritized Dueling DQN Gorila DQN c UNREAL d

Training Time
5 days 10 days 10 days
4 days 9.5 days 9.5 days 4 days
--

Environment Frames 22800M 200M 200M -- 200M 200M
--
250M

Resources (per game) 376 cores, 1 GPU a
1 GPU 1 GPU 16 cores 1 GPU 1 GPU unknown b
16 cores

Median (no-op starts)
434% 223% 178%
-- 172% 79%
96% 331% d

Median (human starts)
358% 153% 125% 117% 115% 68%
78% 250% d

Table 1: Median normalized scores across 57 Atari games. a Tesla P100. b >100 CPUs, with a mixed number of cores per CPU machine. c Only evaluated on 49 games. d Hyper-parameters were tuned per game.

Episode Return (Mean)

Manipulator (Bring Ball)

Humanoid (Run)

750 450

500 250
0 0
750

300

150

2 4 6 8 10 Humanoid (Stand)

0 12 0
750

2 4 6 8 10 Humanoid (Walk)

Number of actors
2 4 12 8 16 32 64

500 500

Episode Return (Mean)

250 250

00 0 2 4 6 8 10 12 0 2 4 6 8 10 12

Training Time (Hours)

Training Time (Hours)

Figure 3: Performance of Ape-X DPG on four continuous control tasks, as a function of wall clock time. Performance improves as we increase the numbers of actors. The black dashed line indicates the maximum performance reached by a standard DDPG baseline over 5 days of training.

Given that Ape-X can harness substantially more computation than most baselines, one might expect it to train faster. Figure 2 shows that this was indeed the case. Perhaps more surprisingly, our agent achieved a substantially higher final performance.
In Table 1 we compare the median human-normalized performance of Ape-X DQN on the Atari benchmark to corresponding metrics as reported for other baseline agents in their respective publications. Whenever available we report results both for no-op starts and for human starts. The human-starts regime (Nair et al., 2015) corresponds to a more challenging generalization test, as the agent is initialized from random starts drawn from games played by human experts. Ape-X's performance is higher than the performance of any of the baselines according to both metrics.

4.2 CONTINUOUS CONTROL
In this second set of experiments we evaluated Ape-X DPG on four continuous control tasks. In the manipulator domain the agent must learn to bring a ball to a specified location. In the humanoid domain the agent must learn to control a humanoid body in order to execute three distinct tasks of increasing complexity: Standing, Walking and Running. Since here we learn from features, rather than directly from pixels, the observation space is always much smaller than it is in the Atari domain. We therefore use small, fully-connected networks (details in the appendix). With 64 actors on this domain, we obtain 14K total FPS (the same number of transitions per second, since here we do not use action repeats). We process 86 batches of 256 transitions per second, or 22K transitions processed per second.
Figure 3 shows that Ape-X DPG achieved very good performance on all four tasks. The figure shows the performance of Ape-X DPG for different numbers of actors: as the number of actors increases our agent becomes increasingly effective at solving these problems rapidly and reliably, outperforming a standard DDPG baseline trained for over 10 times longer. A parallel paper (Anonymous, 2017) builds on this work by combining Ape-X DPG with distributional value functions; the resulting algorithm is successfully applied to further continuous control tasks.

6

Under review as a conference paper at ICLR 2018

Episode Return (Mean)

Alien 24K 16K 8K
0 Ice Hockey
15

45K 30K 15K
0 100K 75K

Beam Rider Kung Fu Master

Demon Attack 60K 40K 20K
0 10K Ms Pacman 7K

Episode Return (Mean)

0
-15 0 8 16 24 32 Training Time (Hours)
Number of Actors:

50K
25K
0 8 16 24 32 Training Time (Hours)
8 32 16 64

5K
2K
0 8 16 24 32 Training Time (Hours)
128 256

Figure 4: Scaling the number of actors. Performance consistently improves as we scale the number of actors from 8 to 256, note that the number of learning updates performed does not depend on the number of actors.

5 ANALYSIS

In this section we describe additional Ape-X DQN experiments on Atari that helped improve our understanding of the framework, and we investigate the contribution of different components.
First, we investigated how the performance scales with the number of actors. We trained our agent with different numbers of actors (8, 16, 32, 64, 128 and 256) for 35 hours on a subset of 6 Atari games. In all experiments we kept the size of the shared experience replay memory fixed at 1 million transitions. Figure 4 shows that the performance consistently improved as the number of actors increased. The appendix contains learning curves for additional games, and a comparison of the scalability of the algorithm with and without prioritized replay. It is perhaps surprising that performance improved so substantially purely by increasing the number of actors, without changing the rate at which the network parameters are updated, the structure of the network, or the update rule. We hypothesize that the proposed architecture helps with a common deep reinforcement learning failure mode, in which the policy discovered is a local optimum in the parameter space, but not a global one, e.g., due to insufficient exploration. Using a large number of actors with varying amounts of exploration helps to discover promising new courses of action, and prioritized replay ensures that when this happens, the learning algorithm focuses its efforts on this important information.
Next, we investigated varying the capacity of the replay memory (see Figure 5). We used a setup with 256 actors, for a median of 37K total environment frames per second (approximately 9K transitions). With such a large number of actors, the contents of the memory is replaced much faster than in most DQN-like agents. We observed a small benefit to using a larger replay capacity. We hypothesize this is due to the value of keeping some high priority experiences around for longer and replaying them. As above, a single learner machine trained the network with median 19 batches per second, each of 512 transitions, for a median of 9.7K transitions processed per second.
Finally, we ran additional experiments in order to disentangle any potential effects of two confounding factors in our scalability analysis: the recency of the experience data in the replay memory, and the diversity of the data-generating policies. The full description of these experiments is confined to the appendix; to summarize, neither factor alone is sufficient to explain the performance we see. We therefore conclude that the results are due substantially to the positive effects of gathering more experience data; namely better exploration of the environment and better avoidance of overfitting.

6 CONCLUSION
We have designed, implemented, and analyzed a distributed framework for prioritized replay in deep reinforcement learning. This architecture achieved state of the art results in a wide range of discrete and continuous tasks, both in terms of wall-clock learning speed and final performance.
In this paper we focused on applying the Ape-X framework to DQN and DPG. However, it could also be combined with any other off-policy reinforcement learning update. For methods that use

7

Under review as a conference paper at ICLR 2018

Episode Return (Mean)

35000 30000 25000 20000 15000 10000
5000 0 0
10000
8000
6000
4000
2000 0

Alien

45000

40000

35000

30000

25000

20000

15000

10000

5000

5 10 15 20 25 30 35

0 0

Ms Pacman

300000

250000

200000

150000

100000

50000

5 10 15 20 25 30 35
Training Time (Hours) Replay Capacity (Transitions):

0 0

Beam Rider

70000

60000

50000

40000

30000

20000

10000

5 10 15 20 25 30 35

0

Star Gunner

60000

50000

40000

30000

20000

10000

5 10 15 20 25 30 35
Training Time (Hours)

0.25M

0.5M

0 0

Demon Attack

5 10 15 20 25 30 35
Wizard Of Wor

5 10 15 20 25 30
Training Time (Hours)
1M 2M

35

Episode Return (Mean)

Figure 5: Varying the capacity of the replay. Agents with larger replay memories perform better on most games. Each curve corresponds to a single run, smoothed over 20 points. The curve for wizard of wor with replay size 25K is incomplete because training diverged, we did not observe this with the other replay sizes.

temporally extended sequences (e.g., Mnih et al., 2016; Wang et al., 2017), the Ape-X framework may be adapted to prioritize sequences of past experiences instead of individual transitions.
Ape-X is designed for regimes in which it is possible to generate large quantities of data in parallel. This includes simulated environments but also a variety of real-world applications, such as robotic arm farms, self-driving cars, online recommender systems, or other multi-user systems in which data is generated by many instances of the same environment (c.f. Silver et al., 2013). In applications where data is costly to obtain or where there is only a limited amount available, our approach will not be directly applicable. With powerful function approximators, overfitting is an issue: generating more training data is the simplest way of addressing it, but may also provide guidance towards data efficient solutions.
Many deep reinforcement learning algorithms are fundamentally limited by their ability to explore effectively in large domains. The Ape-X architecture uses a naive, yet effective, mechanism for addressing this issue: generating a diverse set of experiences and then identifying and learning from the most useful events. The success of this approach ­ based on simple behaviour policies but a prioritized distribution over their experiences ­ suggests that simple and direct approaches to exploration may also be feasible, even for synchronous agents.
Our architecture illustrates that distributed systems are now practical both for research and, potentially, large-scale applications of deep reinforcement learning. We hope that the algorithms, architecture, and analysis we have presented will help to accelerate future efforts in this direction.

ACKNOWLEDGMENTS Omitted to preserve anonymity during the review process.

8

Under review as a conference paper at ICLR 2018
REFERENCES
Mart´in Abadi, Ashish Agarwal, Paul Barham, Eugene Brevdo, Zhifeng Chen, Craig Citro, Greg S Corrado, Andy Davis, Jeffrey Dean, Matthieu Devin, et al. Tensorflow: Large-scale machine learning on heterogeneous distributed systems. arXiv preprint arXiv:1603.04467, 2016.
Guillaume Alain, Alex Lamb, Chinnadhurai Sankar, Aaron Courville, and Yoshua Bengio. Variance reduction in sgd by distributed importance sampling. arXiv preprint arXiv:1511.06481, 2015.
Anonymous. Distributional policy gradients. 2017.
Mohammad Babaeizadeh, Iuri Frosio, Stephen Tyree, Jason Clemons, and Jan Kautz. Reinforcement learning through asynchronous advantage actor-critic on a gpu. In International Conference on Learning Representations, 2017.
Marc G Bellemare, Yavar Naddaf, Joel Veness, and Michael Bowling. The arcade learning environment: An evaluation platform for general agents. J. Artif. Intell. Res. (JAIR), 47:253­279, 2013.
Marc G. Bellemare, Will Dabney, and Re´mi Munos. A distributional perspective on reinforcement learning. In International Conference on Machine Learning, 2017.
Alfredo V. Clemente, Humberto Nicola´s Castejo´n Mart´inez, and Arjun Chandra. Efficient parallel methods for deep reinforcement learning. arXiv preprint arXiv:1705.04862, 2017.
Jeffrey Dean, Greg S. Corrado, Rajat Monga, Kai Chen, Matthieu Devin, Quoc V. Le, Mark Z. Mao, Marc'Aurelio Ranzato, Andrew Senior, Paul Tucker, Ke Yang, and Andrew Y. Ng. Large scale distributed deep networks. In Proceedings of the 25th International Conference on Neural Information Processing Systems, NIPS'12, pp. 1223­1231, 2012.
J. Deng, W. Dong, R. Socher, L.-J. Li, K. Li, and L. Fei-Fei. ImageNet: A Large-Scale Hierarchical Image Database. In CVPR09, 2009.
W Keith Hastings. Monte carlo sampling methods using markov chains and their applications. Biometrika, 57(1):97­109, 1970.
Nicolas Heess, Dhruva TB, Srinivasan Sriram, Jay Lemmon, Josh Merel, Greg Wayne, Yuval Tassa, Tom Erez, Ziyu Wang, S. M. Ali Eslami, Martin A. Riedmiller, and David Silver. Emergence of locomotion behaviours in rich environments. arXiv preprint arXiv:1707.02286, 2017.
Matteo Hessel, Joseph Modayil, Hado van Hasselt, Tom Schaul, Georg Ostrovski, Will Dabney, Dan Horgan, Bilal Piot, Mohammad Azar, and David Silver. Rainbow: Combining improvements in deep reinforcement learning. arXiv preprint arXiv:1710.02298, 2017.
Todd Hester, Matej Vecerik, Olivier Pietquin, Marc Lanctot, Tom Schaul, Bilal Piot, Andrew Sendonaris, Gabriel Dulac-Arnold, Ian Osband, John Agapiou, Joel Z. Leibo, and Audrunas Gruslys. Learning from demonstrations for real world reinforcement learning. CoRR, abs/1704.03732, 2017.
Geoffrey E Hinton. To recognize shapes, first learn to generate images. Prog. Brain Res., 165: 535­547, 2007.
Max Jaderberg, Volodymyr Mnih, Wojciech Marian Czarnecki, Tom Schaul, Joel Z Leibo, David Silver, and Koray Kavukcuoglu. Reinforcement learning with unsupervised auxiliary tasks. In International Conference on Learning Representations, 2017.
Lukasz Kaiser, Aidan N. Gomez, Noam Shazeer, Ashish Vaswani, Niki Parmar, Llion Jones, and Jakob Uszkoreit. One model to learn them all. CoRR, abs/1706.05137, 2017.
Diederik Kingma and Jimmy Ba. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980, 2014.
Alex Krizhevsky. One weird trick for parallelizing convolutional neural networks. arXiv preprint arXiv:1404.5997, 2014.
9

Under review as a conference paper at ICLR 2018
Timothy P Lillicrap, Jonathan J Hunt, Alexander Pritzel, Nicolas Heess, Tom Erez, Yuval Tassa, David Silver, and Daan Wierstra. Continuous control with deep reinforcement learning. In International Conference on Learning Representations, 2016.
Long-H Lin. Self-improving reactive agents based on reinforcement learning, planning and teaching. Machine Learning, 1992.
Ilya Loshchilov and Frank Hutter. Online batch selection for faster training of neural networks. arXiv preprint arXiv:1511.06343, 2015.
Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Andrei A Rusu, Joel Veness, Marc G Bellemare, Alex Graves, Martin Riedmiller, Andreas K Fidjeland, Georg Ostrovski, Stig Petersen, Charles Beattie, Amir Sadik, Ioannis Antonoglou, Helen King, Dharshan Kumaran, Daan Wierstra, Shane Legg, and Demis Hassabis. Human-level control through deep reinforcement learning. Nature, 518(7540):529­533, 26 February 2015.
Volodymyr Mnih, Adria Puigdomenech Badia, Mehdi Mirza, Alex Graves, Timothy Lillicrap, Tim Harley, David Silver, and Koray Kavukcuoglu. Asynchronous methods for deep reinforcement learning. In International Conference on Machine Learning, pp. 1928­1937, 11 June 2016.
Andrew W Moore and Christopher G Atkeson. Prioritized sweeping: Reinforcement learning with less data and less time. Machine learning, 13(1):103­130, 1993.
Arun Nair, Praveen Srinivasan, Sam Blackwell, Cagdas Alcicek, Rory Fearon, Alessandro De Maria, Vedavyas Panneershelvam, Mustafa Suleyman, Charles Beattie, Stig Petersen, Shane Legg, Volodymyr Mnih, Koray Kavukcuoglu, and David Silver. Massively parallel methods for deep reinforcement learning. arXiv preprint arXiv:1507.04296, 15 July 2015.
Danil V Prokhorov and Donald C Wunsch. Adaptive critic designs. IEEE transactions on Neural Networks, 8(5):997­1007, 1997.
Martin Riedmiller. Neural Fitted Q Iteration ­ First Experiences with a Data Efficient Neural Reinforcement Learning Method, pp. 317­328. Springer Berlin Heidelberg, Berlin, Heidelberg, 2005. ISBN 978-3-540-31692-3. doi: 10.1007/11564096 32.
Tom Schaul, John Quan, Ioannis Antonoglou, and David Silver. Prioritized experience replay. In International Conference on Learning Representations, 2016.
David Silver, Leonard Newnham, David Barker, Suzanne Weller, and Jason McFall. Concurrent reinforcement learning from customer interactions. In Sanjoy Dasgupta and David McAllester (eds.), Proceedings of the 30th International Conference on Machine Learning, volume 28 of Proceedings of Machine Learning Research, pp. 924­932, Atlanta, Georgia, USA, 17­19 Jun 2013. PMLR. URL http://proceedings.mlr.press/v28/silver13.html.
David Silver, Guy Lever, Nicolas Heess, Thomas Degris, Daan Wierstra, and Martin Riedmiller. Deterministic policy gradient algorithms. In Proceedings of the 31st International Conference on Machine Learning (ICML-14), pp. 387­395, 2014.
David Silver, Aja Huang, Chris J Maddison, Arthur Guez, Laurent Sifre, George Van Den Driessche, Julian Schrittwieser, Ioannis Antonoglou, Veda Panneershelvam, Marc Lanctot, et al. Mastering the game of go with deep neural networks and tree search. Nature, 529(7587):484­489, 2016.
Richard S Sutton. Learning to predict by the methods of temporal differences. Machine learning, 3 (1):9­44, 1988.
Richard S Sutton and Andrew G Barto. Reinforcement learning: An introduction. MIT press Cambridge, 1998.
Richard S Sutton and Andrew G Barto. Reinforcement learning: An introduction, 2nd edition. 2017.
Emanuel Todorov, Tom Erez, and Yuval Tassa. Mujoco: A physics engine for model-based control. In Intelligent Robots and Systems (IROS), 2012 IEEE/RSJ International Conference on, pp. 5026­ 5033. IEEE, 2012.
10

Under review as a conference paper at ICLR 2018
George E Uhlenbeck and Leonard S Ornstein. On the theory of the brownian motion. Physical review, 36(5):823, 1930.
Hado van Hasselt. Double Q-learning. In Advances in Neural Information Processing Systems, pp. 2613­2621, 2010.
Hado van Hasselt, Arthur Guez, and David Silver. Deep reinforcement learning with double Qlearning. In Advances in Neural Information Processing Systems, 2016.
Ziyu Wang, Tom Schaul, Matteo Hessel, Hado van Hasselt, Marc Lanctot, and Nando de Freitas. Dueling network architectures for deep reinforcement learning. In International Conference on Machine Learning, 2016.
Ziyu Wang, Victor Bapst, Nicolas Heess, Volodymyr Mnih, Remi Munos, Koray Kavukcuoglu, and Nando de Freitas. Sample efficient actor-critic with experience replay. In International Conference on Learning Representations, 2017.
Paul J Werbos. A menu of designs for reinforcement learning over time. Neural networks for control, pp. 67­95, 1990.
11

Under review as a conference paper at ICLR 2018

24K Alien 18K 12K 6K

Beam Rider 45K
30K
15K

0K 80K Demon Attack

0K 320K

Star Gunner

60K 240K

40K 160K

20K 80K

0K 0 15 30 45 60 Training Time (Hours)

0K 0 15 30 45 60 Training Time (Hours)

n = 32 k=1
n = 32 k=2

n = 32 k=4
n = 32 k=8

n = 256 k=1

Figure 6: Testing whether improved performance is caused by recency alone: n denotes the number of actors, k the number of times each transition is replicated in the replay. The data in the run with n = 32, k = 8 is therefore as recent as the data in the run with n = 256, k = 1, but performance is not as good.

64 Actors 30K

128 Actors

Alien

20K

10K

0 60K

Demon Attack

40K

20K

0 0 8 16 24 32 40 0 8 16 24 32 40 Training Time (Hours) Training Time (Hours)
All distinct epsilons 6 distinct epsilons

Figure 7: Varying the data-generating policies: Red: fixed set of 6 values for . Blue: full range of values for . In both cases, the curve plotted is from a separate actor that does not add data to the replay memory, and which follows an -greedy policy with
= 0.00164.

A RECENCY OF EXPERIENCE

In our main experiments we do not change the size of the replay memory in proportion to the number of actors, so by changing the number of actors we also increased the rate at which the contents of the replay memory is replaced. This means that in the experiments with more actors, transitions in the replay memory are more recent: they are generated by following policies whose parameters are closer to version of the parameters being optimized by the learner, and in this sense they are more onpolicy. Could this alone be sufficient to explain the improved performance? If so, we might be able to recover the results without needing a large number of actor machines. To test this, we constructed an experiment wherein we replicate the rate at which the contents of the replay memory is replaced in the 256-actor experiments, but instead of actually using 256 actors, we use 32 actors but add each transition they generate to the replay memory 8 times over. In this setup, the contents of the replay memory is similarly generated by policies with a recent version of the network parameters: the only difference is that the data is not as diverse as in the 256-actor case. We observe (see Figure 6) that this does not recover the same performance, and therefore conclude that the recency of the experience alone is not sufficient to explain the performance of our method. Indeed, we see that adding the same data multiple times can sometimes harm performance, since although it increases recency this comes at the expense of diversity.

B VARYING THE DATA-GENERATING POLICIES
Another factor that could conceivably contribute to the scalability of our algorithm is the fact that each actor has a different . To determine the extent to which this impacts upon the performance, we ran an experiment (see Figure 7) with some simple variations on the mechanism we use to choose the policies that generate the data we train on. The first alternative we tested is to choose a small fixed set of 6 values for , instead of the full range that we typically use. In this test, we use prioritized replay as normal, and we find that the results with the full range of are overall slightly better. However, it is not essential for achieving good results within our distributed framework.
12

Under review as a conference paper at ICLR 2018
C ATARI: ADDITIONAL DETAILS
The frames received from the environment are preprocessed on the actor side with the standard transformations introduced by DQN. This includes greyscaling, frame stacking, repeating actions 4 times, and clipping rewards to [-1, 1].
The learner waits for at least 50000 transitions to be accumulated in the replay before starting learning. We use a Centered RMSProp optimizer with a learning rate of 0.00025 / 4, decay of 0.95, epsilon of 1.5e-7, and no momentum to minimize the multi-step loss (with n = 3). Gradient norms are clipped to 40. The target network used in the loss calculation is copied from the online network every 2500 training batches. We use the same network as in the Dueling DDQN agent.
D CONTINUOUS CONTROL: ADDITIONAL DETAILS
The critic network has a layer with 400 units, followed by a tanh activation, followed by another layer of 300 units. The actor network has a layer with 300 units, followed by a tanh activation, followed by another layer of 200 units. The gradient used to update the actor network is clipped to [-1, 1], element-wise. Training uses the Adam optimizer (Kingma & Ba (2014)) with learning rate of 0.0001. The target network used in the loss calculation is copied from the online network every 100 training batches.
Replay sampling priorities are set according to the absolute TD error as given by the critic, and are sampled by the learner using proportional prioritized sampling (see appendix F) with priority exponent sample = 0.6. To maintain a fixed replay capacity of 106, transitions are periodically evicted using proportional prioritized sampling, with priority exponent evict = -0.4.
Unlike the original DPG algorithm which applies autocorrelated noise sampled from a OrnsteinUhlenbeck process (Uhlenbeck & Ornstein (1930)), we apply exploration noise to each action sampled from a normal distribution with  = 0.3. Evaluation is performed using the noiseless deterministic policy. Hyperparameters are otherwise as per DQN.
Benchmarking was performed in two continuous control domains ((a) Humanoid and (b) Manipulator, see Figure 8) implemented in the MuJoCo physics simulator (Todorov et al. (2012)). Humanoid is a humanoid walker with action, state and observation dimensionalities |A| = 21, |S| = 55 and |O| = 67 respectively. Three Humanoid tasks were considered: walk (reward for exceeding a minimum velocity), run (reward proportional to movement speed) and stand (reward proportional to standing height). Manipulator is a 2-dimensional planar arm with |A| = 2, |S| = 22 and |O| = 37, which receives reward for catching a randomly-initialized moving ball.

(a) Humanoid domain.

(b) Manipulator domain.

Figure 8: Continuous control domains considered for benchmarking Ape-X DPG: (a) Humanoid, and (b) Manipulator. All tasks simulated in the MuJoCo physics simulator (Todorov et al. (2012)).

E TUNING
On Atari, we performed some limited tuning of the learning rate and batch size: we found that larger batch sizes contribute significantly to performance, when using many actors. We tried batch
13

Under review as a conference paper at ICLR 2018
sizes from {32, 128, 256, 512, 1024}, seeing clear benefits up to 512. We attempted increasing the learning rate to 0.00025 with the larger batch sizes but this destabilized training on some games. We also tried a lower learning rate of 0.00025 / 8, but this did not reliably improve results. Likewise for continuous control, we experimented with batch sizes {32, 128, 256, 512, 1024} and learning rates from 10-3 to 10-5. We also experimented with the prioritization exponents  from 0.0 to 1.0, with results proving essentially consistent within the range [0.3, 0.7] (beyond 0.7, training would sometimes become unstable and diverge). For the experiments with many actors, we set the period for updating network parameters on the actors to be high enough that the learner was not overloaded with requests, and we set the number of transitions that are locally accumulated on each actor to be high enough that the replay server would not be overloaded with network traffic, but we did not otherwise tune those parameters and have not observed them to have significant impact on the learning dynamics.
F IMPLEMENTATION
The algorithm is implemented using TensorFlow (Abadi et al., 2016). Replay data is kept in a distributed in-memory key-value store implemented using custom TensorFlow ops. The ops allow adding, reading, and removing batches of data efficiently. Each actor assigns a unique key to each n-step transition it observes, and adds the transition data as a tuple (st-1, at-1, rt..t+n, t..t+n, st+n) to the key-value store. We also implemented ops for efficiently maintaining and sampling from a prioritized distribution over the keys, using the algorithm for proportional prioritization described in Schaul et al. (2016). The probability of sampling a transition is pk / k pk where pk is the priority of the transition with key k. The exponent  controls the amount of prioritization and when  = 0 uniform sampling is recovered. The proportional variant sets priority pk = |k| where k is the TD error for transition k. Whenever a batch of data is added to or removed from the store, or is processed by the learner, this distribution is correspondingly updated, recording any change to the set of valid keys and the priorities associated with them. TensorFlow queues are used to buffer experience data on actor, batching it together before adding to the replay memory. They are also used to buffer samples on the learner: fetching data from replay and decompressing it is done using a learner's CPU, in parallel with the gradients being computed on the GPU. In both cases these queues are crucial to the efficiency and scalability of the implementation, since they allow all data to be operated on in batch and reduce the number of necessary remote procedure calls.
14

Under review as a conference paper at ICLR 2018

Episode Return (Mean)

60K 45K 30K 15K
0
1000K 750K 500K 250K
0

Alien Atlantis

12K 9K 6K 3K
0
2K 1.5K
1K 500
0

Amidar Bank Heist

40K 30K 20K 10K
0
120K 90K 60K 30K
0

Assault Battle Zone

1000K 750K 500K 250K
0
60K 45K 30K 15K
0

Asterix Beam Rider

160K 120K 80K 40K
0
32K 24K 16K 8K
0

Asteroids Berzerk

Episode Return (Mean)

Episode Return (Mean)

80 Bowling 60 40 20 0

400K 300K 200K 100K
0

Crazy Climber

80 40 0
240K 180K 120K 60K
0

Boxing Defender

1K Breakout 750 500 250
0

120K 90K 60K 30K
0

Demon Attack

16K Centipede 12K 8K 4K
0
30 Double Dunk 15 0 -15 -30

450K Chopper Command 300K 150K
0

2K 1.8K 1.2K
600 0

Enduro

Episode Return (Mean)

Episode Return (Mean)

Episode Return (Mean)

100 Fishing Derby 50 0 -50 -100

40K Hero 30K 20K 10K
0

160K 120K 80K 40K
0

Kung Fu Master

40 Freeway 30 20 10 0

16K Frostbite 12K 8K 4K
0

40 Ice Hockey 20 0 -20

24K Jamesbond 18K 12K 6K
0

3K Montezuma Revenge 16K Ms Pacman

2K 12K

1.6K

8K

800 4K

00

80K Gopher 60K 40K 20K
0
16K Kangaroo 12K 8K 4K
0
32K Name This Game 24K 16K 8K
0

2K 1.8K 1.2K
600 0
16K 12K 8K 4K
0
320K 240K 160K 80K
0

Gravitar Krull
Phoenix

Episode Return (Mean)

Episode Return (Mean)

0 -150 -300 -450 -600
320K 240K 160K 80K
0

Pitfall Road Runner

30 Pong 15 0 -15 -30
100 Robotank 75 50 25 0

750 500 250
0 -250
240K 180K 120K 60K
0

Private Eye Seaquest

400K 300K 200K 100K
0
-8K -16K -24K -32K

Qbert Skiing

80K 60K 40K 20K
0
4K 3K 1.5K
0

Riverraid Solaris

Episode Return (Mean)

Episode Return (Mean)

32K Space Invaders 24K 16K 8K
0

400K 300K 200K 100K
0

Star Gunner

10 Surround 5 0 -5 -10

30 Tennis 15 0 -15 -30

120K 90K 60K 30K
0

Time Pilot

Episode Return (Mean)

320 Tutankham 240 160 80
0

200K

Yars Revenge

150K

100K

50K

0 0 40 80 120 160 200 Training Time (Hours)

200K 150K 100K 50K
0

Up N Down

60K Zaxxon 45K 30K 15K
0 0 40 80 120 160 200 Training Time (Hours)

2K Venture

800K

Video Pinball

1.5K

600K

1K 400K

500 200K

0 0 40 80 120 160 200 Training Time (Hours)

0 0 40 80 120 160 200 Training Time (Hours)

80K Wizard Of Wor 60K 40K 20K
0 0 40 80 120 160 200 Training Time (Hours)

Episode Return (Mean)

Figure 9: Training curves for 57 Atari games (performance against wall clock time). Green: DQN baseline. Purple: Rainbow baseline. Orange: A3C baseline. Blue: Ape-X DQN with 360 actors, 1 replay server and 1 Tesla P100 GPU learner. The anomaly in Riverraid is due to an infrastructure error.

15

Under review as a conference paper at ICLR 2018

Episode Return (Mean)

12K Alien 9K 6K 3K
0

4K 3K 1.5K
0

Amidar

24K Assault 18K 12K 6K
0

600K 450K 300K 150K
0

Asterix

120K 90K 60K 30K
0

Asteroids

Episode Return (Mean)

1000K 750K 500K 250K
0

Atlantis

2K 1.5K
1K 500
0

Bank Heist

80K Battle Zone 60K 40K 20K
0

45K Beam Rider 30K 15K
0

6K 4K 3K 1.5K
0

Berzerk

Episode Return (Mean)

80 Bowling 60 40 20 0

Boxing 90
60
30

800 Breakout 600 400 200
0

8K Centipede 6K 4K 2K
0

12K Chopper Command 9K 6K 3K
0

Episode Return (Mean)

200K 150K 100K 50K
0

Crazy Climber

160K 120K 80K 40K
0

Defender

120K 90K 60K 30K
0

Demon Attack

30 Double Dunk 15 0 -15 -30

2K 1.8K 1.2K
600 0

Enduro

Episode Return (Mean)

100 Fishing Derby 50 0 -50 -100

40 Freeway 30 20 10 0

12K Frostbite 9K 6K 3K
0

80K Gopher 60K 40K 20K
0

2K 1.5K
1K 500
0

Gravitar

Episode Return (Mean)

40K Hero 30K 20K 10K
0

20 Ice Hockey 10 0 -10 -20

16K Jamesbond 12K 8K 4K
0

16K Kangaroo 12K 8K 4K
0

12K Krull 10K 7K 5K 2K

Episode Return (Mean)

80K Kung Fu Master 60K 40K 20K
0

600 Montezuma Revenge 450 300 150
0

6K 4K 3K 1.5K
0

Ms Pacman

24K Name This Game 18K 12K 6K
0

320K 240K 160K 80K
0

Phoenix

Episode Return (Mean)

Pitfall 0 -150 -300

30 Pong 15 0 -15 -30

450 Private Eye 300 150
0 -150

32K Qbert 24K 16K 8K
0

32K Riverraid 24K 16K 8K
0

Episode Return (Mean)

160K 120K 80K 40K
0

Road Runner

80 Robotank 60 40 20 0

120K 90K 60K 30K
0

Seaquest

-10K -15K -20K -25K -30K

Skiing

6K 4K 3K 1.5K
0

Solaris

Episode Return (Mean)

32K Space Invaders 24K 16K 8K
0

240K 180K 120K 60K
0

Star Gunner

10 Surround 5 0 -5 -10

5 Tennis 0 -5 -10 -15

16K Time Pilot 12K 8K 4K
0

Episode Return (Mean)

320 Tutankham 240 160 80
0

120K

Yars Revenge

90K

60K

30K

0

0

500M

1B

Environment Frames

160K 120K 80K 40K
0

Up N Down

40K Zaxxon

30K

20K

10K

0

0

500M

1B

Environment Frames

1.2K

Venture

800K

Video Pinball

900 600K

600 400K

300 200K

0

0

500M

1B

Environment Frames

0

0

500M

1B

Environment Frames

32K Wizard Of Wor

24K

16K

8K

0

0

500M

1B

Environment Frames

Episode Return (Mean)

Figure 10: Training curves for 57 Atari games (performance against environment frames). Only the first billion frames are shown, corresponding to 5-6 hours of training for Ape-X. Green: DQN baseline. Purple: Rainbow baseline. Blue: ApeX-DQN with 360 actors, 1 replay server and 1 Tesla P100 GPU learner.

16

Under review as a conference paper at ICLR 2018

50000

Scalability of Data Generation

Environment Frames per Second

40000

30000

20000

10000

08

16 32 64 128 Number of Actor Workers

256

Figure 11: Speed of data generation scales linearly with the number of actors.

Alien

Beam Rider

Demon Attack

Ice Hockey

Kung Fu
Master

30000
20000
10000
0 60000 45000 30000 15000
0

32 Actors

64 Actors

128 Actors

256 Actors

60000 40000 20000
0 40
20
0
-20

90000
60000
30000
0
12000 9000 6000 3000
0

120000 80000 40000
0

24000 16000 8000
0

240000

160000

80000

0 0 8 16 24 32 0 8 16 24 32 0 8 16 24 32 0 8 16 24 32

Training Time Training Time Training Time Training Time

(Hours)

(Hours)

(Hours)

(Hours)

Ms Pacman

Seaquest

Space Invaders

Star Gunner

Figure 12: Training curves showing performance against wall clock time for various numbers of actors on a selection of Atari games. Blue: prioritized replay, with learning rate 0.00025 / 4. Red: uniform replay, with learning rate 0.00025. For both prioritized and uniform, we tried both of these learning rates and selected the best. Both variants benefit from larger numbers of actors, but prioritized can better take advantage of the increased amount of data. In the 256-actor run, prioritized is equal or better in 7 of 9 games.

17

Under review as a conference paper at ICLR 2018

Game

No-op starts Human starts

alien amidar assault asterix asteroids atlantis bank heist battle zone beam rider berzerk bowling boxing breakout centipede chopper command crazy climber defender demon attack double dunk enduro fishing derby freeway frostbite gopher gravitar hero ice hockey jamesbond kangaroo krull kung fu master montezuma revenge ms pacman name this game phoenix pitfall pong private eye qbert riverraid road runner robotank seaquest skiing solaris space invaders star gunner surround tennis time pilot tutankham up n down venture video pinball wizard of wor yars revenge zaxxon

40,804.9 8,659.2 24,559.4 313,305.0 155,495.1 944,497.5 1,716.4 98,895.0 63,305.2 57,196.7
17.6 100.0 800.9 12,974.0 721,851.0 320,426.0 411,943.5 133,086.4
23.5 2,177.4
44.4 33.7 9,328.6 120,500.9 1,598.5 31,655.9 33.0 21,322.5 1,416.0 11,741.4 97,829.5 2,500.0 11,255.2 25,783.3 224,491.1 -0.6 20.9 49.8 302,391.3 63,864.4 222,234.5 73.8 392,952.3 -10,789.9 2,892.9 54,681.0 434,342.5
7.1 23.9 87,085.0 272.6 401,884.3 1,813.0 565,163.2 46,204.0 148,594.8 42,285.5

17,731.5 1,047.3
24,404.6 283,179.5 117,303.4 918,714.5
1,200.8 92,275.0 72,233.7 55,598.9
30.2 80.9 756.5 5,711.6 576,601.5 263,953.5 399,865.3 133,002.1 22.3 2,042.4 22.4 29.0 6,511.5 121,168.2 662.0 26,345.3 24.0 18,992.3 577.5 8,592.0 72,068.0 1,079.0 6,135.4 23,829.9 188,788.5 -273.3 18.7 864.7 380,152.1 49,982.8 127,111.5 68.5 377,179.8 -11,359.3 3,115.9 50,699.3 432,958.0
5.5 23.0 71,543.0 127.7 347,912.2 935.5 873,988.5 46,897.0 131,701.1 37,672.0

Table 2: Scores obtained by Ape-X DQN in final evaluation, under the standard no-op starts and human starts

regimes. In some games the scores are higher than in the training curves: this is because the maximum episode

length is shorter during training.

18

