Under review as a conference paper at ICLR 2018
SPECTRALNET: SPECTRAL CLUSTERING USING DEEP NEURAL NETWORKS
Anonymous authors Paper under double-blind review
ABSTRACT
Spectral clustering is a leading and popular technique in unsupervised data analysis. Two of its major limitations are scalability and generalization of the spectral embedding (i.e., out-ofsample-extension). In this paper we introduce a deep learning approach to spectral clustering that overcomes the above shortcomings. Our network, which we call SpectralNet, learns a map that embeds input data points into the eigenspace of their associated graph Laplacian matrix and subsequently clusters them. We train SpectralNet using a procedure that involves constrained stochastic optimization. Stochastic optimization allows it to scale to large datasets, while the constraints, which are implemented using a special-purpose output layer, allow us to keep the network output orthogonal. Moreover, the map learned by SpectralNet naturally generalizes the spectral embedding to unseen data points. To further improve the quality of the clustering, we replace the standard pairwise Gaussian affinities with affinities leaned from unlabeled data using a Siamese network. Additional improvement can be achieved by applying the network to code representations produced, e.g., by standard autoencoders. Our end-to-end learning procedure is fully unsupervised. In addition, we apply VC dimension theory to derive a lower bound on the size of SpectralNet. State-of-the-art clustering results are reported for both the MNIST and Reuters datasets.
1 INTRODUCTION
Discovering clusters in unlabeled data is a task of significant scientific and practical value. With technological progress images, texts, and other types of data are acquired in large numbers. Their labeling, however, is often expensive, tedious, or requires expert knowledge. Clustering techniques provide useful tools to analyze such data and to reveal its underlying structure.
Spectral Clustering (Shi & Malik, 2000; Ng et al., 2002; Von Luxburg, 2007) is a leading and highly popular clustering algorithm. Motivated by cost functions that seek to discover tight clusters of balanced size, spectral clustering employs relaxation of the cost functions that allows it to embed the data in the eigenspace of the Laplacian matrix, derived from the pairwise similarities between data points. k-means is then used to obtain the clusters. Several properties make spectral clustering appealing: First, its embedding optimizes a natural cost function, minimizing pairwise distances between similar data points; moreover, this optimal embedding can be found analytically. Second, spectral clustering variants arise as relaxations of graph balanced-cut problems (Von Luxburg, 2007). Third, spectral clustering was shown to outperform other popular clustering algorithms such as k-means (Von Luxburg, 2007), arguably due to its ability to handle non-convex clusters. Finally, spectral clustering has a solid probabilistic interpretation, since the Euclidean distance in the embedding space is equal to a diffusion distance, which, informally, measures the time it takes probability mass to transfer between points, via other points in the dataset (Nadler et al., 2006; Coifman & Lafon, 2006a).
While spectral embedding of data points can be achieved by a simple eigen-decomposition of their graph Laplacian matrix, with large datasets direct computation of eigenvectors may be prohibitive. Moreover, generalizing a
1

Under review as a conference paper at ICLR 2018
Figure 1: Illustrative 2D and 3D examples showing the results of our SpectralNet clustering (top) compared to typical results obtained with DCN, VaDE and DEPICT (bottom) on simulated datasets in 2D and 3D. Our approach successfully finds these non-convex clusters, whereas the competing algorithms fail on all five examples. (The full set of results for these algorithms is shown in Figure 4 in Appendix A.)
spectral embedding to unseen data points, a task commonly referred to as out-of-sample-extension (OOSE), is a non-trivial task; see, for example, (Bengio et al., 2004; Fowlkes et al., 2004; Coifman & Lafon, 2006b). In this work we introduce SpectralNet, a deep learning approach to spectral clustering, which addresses the scalability and OOSE problems pointed above. Specifically, it is trained in a stochastic fashion, which allows it to scale. Moreover, once trained, it provides a function, implemented as a feed-forward network, that maps each input data point to its spectral embedding coordinates. This map can easily be applied to new test data. Unlike optimization of standard deep learning models, SpectralNet is trained using constrained optimization, where the constraint (orthogonality of the net outputs) is enforced by adding a linear layer, whose weights are set by the QR decomposition of its inputs. In addition, as good affinity functions are crucial for the success of spectral clustering, rather than using the common Gaussian affinity, we show how Siamese networks can be trained from unlabeled data to learn pairwise affinities and consequently significantly improve the quality of the clustering. Further improvement can be achieved if our network is applied to transformed data obtained by an autoencoder (AE). On the theoretical front, we utilize VC-dimension theory to derive a lower bound on the size of neural networks that compute spectral clustering. Our experiments indicate that our network indeed approximates the Laplacian eigenvectors well, allowing the network to cluster challenging non-convex point sets, which recent deep network based methods fail to handle; see examples in Figure 1. Finally, SpetralNet achieves state-of-theart clustering results on both the MNIST handwritten digit dataset and the Reuters document dataset, whose size makes standard spectral clustering inapplicable.
2 RELATED WORK
Recent deep learning approaches to clustering largely attempt to learn a code for the input that is amenable to clustering according to either the k-means or mixture of gaussians clustering models. DCN (Yang et al., 2017) directly optimizes a loss composed of a reconstruction term (for the code) and the k-means functional. DEC (Xie et al., 2016) iteratively updates a target distribution to sharpen cluster associations. DEPICT (Dizaji et al., 2017) adds a regularization term that prefers balanced clusters. All three methods are pre-trained as autoencoders, while DEPICT also initializes its target distribution using k-means (or other standard clustering algorithms). Several other recent approaches rely on a variational autoencoder that utilizes a Gaussian mixture prior, see, for example, VaDE (Zheng et al., 2016) and GMVAE (Dilokthanakul et al., 2016). Different approaches are taken by Chen (2015), who uses a deep belief net followed by non-parametric maximum margin clustering (NMMC), and Yang et al. (2016), who introduce a recurrent-agglomerative framework to image clustering.
2

Under review as a conference paper at ICLR 2018
While these approaches achieve accurate clustering results on standard datasets (such as the MNIST and Reuters), the use of the k-means criterion, as well as the Gaussian mixture prior, seems to introduce an implicit bias towards the formation of clusters with convex shapes. This limitation seems to hold even in code space. This bias is demonstrated in Figure 1(bottom), which shows the failure of several of the above approaches on relatively simple clustering tasks. In contrast, as is indicated in Figure 1(top), our SpectralNet approach appears to be less vulnerable to such bias. The full set of runs can be found in Appendix A.
In the context of spectral clustering, Tian et al. (2014) learn an autoencoder that maps the rows of a graph Laplacian matrix onto the corresponding spectral embedding, and then use k-means in code space to cluster the underlying data. Unlike our work, which learns to map an input data point to its spectral embedding, Tian et al.'s network takes as input an entire row of the graph Laplacian, and therefore OOSE is impractical, as it involves computing in preprocessing the affinities of each new data point to all the training data.
Yi et al. (2016) address the problem of 3D shape segmentation. Their work, which focuses on learning graph convolutions, uses a graph spectral embedding through eigenvector decomposition, which is not learned. In addition, we enforce orthogonalization stochastically through a constraint layer, while they attempt to learn orthogonalized functional maps by adding an orthogonalization term to the loss function, which involves non-trivial balancing between two loss components.
Other deep learning works use a spectral approach in the context of supervised learning. Law et al. (2017) apply supervised metric learning, showing that their method approximates the eigenvectors of a 0-1 affinity matrix constructed from the true labels. Mishne et al. (2017) trained a network to map graph Laplacian matrices to their eigenvectors using supervised regression. Their approach, however, requires the true eigenvectors for training, and hence does not easily scale to large datasets.
Finally, a number of papers showed that stochastic gradient descent can be used effectively to compute the principal components of covariance matrices, see, e.g., (Shamir, 2015) and references therein. The setup in these papers assumes that in each iteration a noisy estimate of the entire input matrix is provided. In contrast, in our work we use in each iteration only a small submatrix of the affinity matrix, corresponding to a small minibatch. n future work, we plan to examine how these algorithms can be adapted to improve the convergence rate of our proposed network.
3 SPECTRALNET
In this section we present our proposed approach, describe its key components, and explain its connection to spectral clustering. Consider the following standard clustering setup: Let X = {x1, . . . , xn}  Rd denote a collection of unlabeled data points drawn from some unknown distribution D; given a target number of clusters k and a distance measure between points, the goal is to learn a similarity measure between points in X and use it to learn a map that assigns each of x1, . . . , xn to one of k possible clusters, so that similar points tend to be grouped in the same cluster. As in classification tasks we further aim to use the learned map to determine the cluster assignments of new, yet unseen, points drawn from D. Such out-of-sample-extension is based solely on the learned map, and requires neither computation of similarities between the new points and the training points nor re-clustering of combined data.
In this work we propose SpectralNet, a neural network approach for spectral clustering. Once trained, SpectralNet computes a map F : Rd  Rk and a cluster assignment function c : Rk  {1, . . . , k}. It maps each input point x to an output y = F(x) and provides its cluster assignment c(y). The spectral map F is implemented using a neural network, and the parameter vector  denotes the network weights.
The training of SpectralNet consists of three components: (i) unsupervised learning of an affinity given the input distance measure, via a Siamese network (see Section 3.2); (ii) unsupervised learning of the map F by optimizing a spectral clustering objective while enforcing orthogonality (see Section 3.1); (iii) learning the cluster assignments, by k-means clustering in the embedded space.
3

Under review as a conference paper at ICLR 2018

3.1 LEARNING THE SPECTRAL MAP F

In this section we describe the main learning step in SpectralNet, component (ii) above. To this end, let w : Rd × Rd  [0, ) be a symmetric affinity function, such that w(x, x ) expresses the similarity between x and x . Given w, we would like points x, x which are similar to each other (i.e., with large w(x, x )) to be
embedded close to each other. Hence, we define the loss

LSpectralNet() = E w(x, x ) y - y 2 ,

(1)

where y, y  Rk, the expectation is taken with respect to pairs of i.i.d. elements (x, x ) drawn from D, and  denotes the parameters of the map y = F(x). Clearly, the loss LSpectralNet() can be minimized by mapping all points to the same output vector (F(x) = y0 for all x). To prevent this, we require that the outputs will be orthonormal in expectation with respect to D, i.e.,

E yyT = Ik×k.

(2)

As the distribution D is unknown, we replace the expectations in (1) and (2) by their empirical analogues. Fur-
thermore, we perform the optimization in a stochastic fashion. Specifically, at each iteration we randomly sample a minibatch of m samples, which without loss of generality we denote x1, . . . , xm  X , and organize them in an m × d matrix X whose ith row contains xTi . We then minimize the loss

1 LSpectralNet() = m2

m
Wi,j yi - yj 2,

i,j=1

(3)

where yi = F(xi) and W is a m × m matrix such that Wi,j = w(xi, xj). The analogue of (2) for a small

minibatch is

1 YTY m

= Ik×k,

(4)

where Y is a m × k matrix of the outputs whose ith row is yiT .

We implement the map F as a general neural network whose last layer enforces the orthogonality constraint

(4). This layer gets input from k units, and acts as a linear layer with k outputs, where the weights are set to

orthogonalize the output Y for the minibatch X. Let Y~ denote the m × k matrix containing the inputs to this

layer for X (i.e., the outputs of F over the minibatch before orthogonalization), a linear map that orthogonalizes the columns of Y~ is computed through its QR decomposition. Specifically, for any matrix A such that AT A is

full rank, one can obtain the QR decomposition via the Cholesky decomposition AT A = LLT , where L is a

lower triangular matrix, and then setting Q = A L-1 T . This is verified in Appendix B. Therefore, in order

to orthogonalize

Y~ ,

the last

layer

multiplies Y~

from

the

right by

 m

L~ -1

T
,

where

L~

is

obtained

from

the

Cholesky

decomposition

of

Y~

and

the

 m

factor

is

needed

to

satisfy

(4).

We train this spectral map in a coordinate descent fashion, where we alternate between orthogonalization and gradient steps. Each of these steps uses a different minibatch (possibly of different sizes), sampled uniformly from the training set X . In each orthogonalization step we use the QR decomposition to tune the weights of the last layer. In each gradient step we tune the remaining weights using standard backpropagation. Once SpectralNet is trained, all the weights are freezed, including those of the last layer, which simply acts as a linear layer. Finally, to obtain the cluster assignments c1, . . . c2, we propagate x1, . . . xn through it to obtain the embeddings y1, . . . , yn  Rk, and perform k-means on them, obtaining k cluster centers, as in standard spectral clustering. These algorithmic steps are summarized below in Algorithm 1 in Sec. 3.3.

Connection with Spectral Clustering The loss (3) can also be written as

2 LSpectralNet() = m2 trace

Y T (D - W )Y

,

4

Under review as a conference paper at ICLR 2018

where D is a m × m diagonal matrix such that Di,i = j Wi,j. The symmetric, positive semi-definite matrix D - W forms the (unnormalized) graph Laplacian of the minibatch x1, . . . xm. For k = 1 the loss is minimized when y is the eigenvector of D - W corresponding to the smallest eigenvalue. Similarly, for general k, under the constraint (4), the minimum is attained when the column space of Y is the subspace of the k eigenvectors corresponding to the smallest k eigenvalues of D - W . Note that this subspace includes the constant vector whose inclusion does not affect the final cluster assignment.
Hence, SpectralNet approximates spectral clustering, where the main differences are that the training is done in a stochastic fashion, and that the orthogonality constraint with respect to the full dataset X holds only approximately. SpectralNet therefore trades accuracy with scalability and generalization ability. Specifically, while its outputs are an approximation of the true eigenvectors, the stochastic training enables its scalability and thus allows one to cluster large datasets that are prohibitive for standard spectral clustering. Moreover, once trained, SpectralNet provides a parametric function whose image for the training points is (approximately) the eigenvectors of the graph Laplacian. This function can now naturally embed new test points, which were not present at training time. Our experiments with the MNIST dataset (Section 5) indicate that the outputs of SpectralNet closely approximate the true eigenvectors.
Finally, as in common spectral clustering applications, cluster assignments are determined by applying k-means to the embeddings y1, . . . yn. We note that the k-means step can be replaced by other clustering algorithms. Our preference to use k-means is based on the interpretation (for normalized Laplacian matrices) of the Euclidean distance in the embedding space as diffusion distance in the input space (Nadler et al., 2006; Coifman & Lafon, 2006a).
Batch size considerations In standard classification or regression loss functions, the loss is a sum over the losses of individual examples. In contrast, SpectralNet loss (3) is summed over pairs of points, and each summand describes relationships between data points. This relation is encoded by the full n × n affinity matrix Wfull (which we never compute explicitly). The minibatch size m should therefore be sufficiently large to capture the structure of the data. For this reason, it is also highly important that minibatches will be sampled at random from the entire dataset at each iteration step, and not be fixed across epochs. When the minibatches are fixed, the knowledge of Wfull is reduced to a (possibly permuted) diagonal sequence of m × m blocks, thus ignoring many of the entries of Wfull. In addition, while the output layer orthogonalizes Y~ , we do not have any guarantees on how well it orthogonalizes other random minibatches. However, in our experiments we observed that if m is large enough, it approximately orthogonalizes other batches as well, and its weights stabilize as training progresses. Therefore, to train SpectralNet, we use larger minibatches compared to common choices made by practitioners in the context of classification. In our experiment on MNIST we use minibatches of size 512 that are re-sampled randomly at every iteration step. With Reuters, however, we found that minibatches of size 128 suffice.

3.2 LEARNING AFFINITIES USING A SIAMESE NETWORK

Choosing a good affinity measure is crucial to the success of spectral clustering. In many applications, practitioners use an affinity measure that is positive for a set of nearest neighbor pairs, combined with a Gaussian kernel with some scale  > 0, e.g.,

Wi,j =

exp

- xi-xj 2
22

,

xj is among the nearest neighbors of xi

0, otherwise,

(5)

where one typically symmetrizes W , for example, by setting Wi,j  (Wi,j + Wj,i)/2.

The affinity captured by a Gaussian kernel may be overly simplistic; seeking methods that can capture more complex affinity relations might turn out advantageous. Siamese nets (Hadsell et al., 2006) are trained to learn affinity relations between data points; we empirically found that the unsupervised application of a Siamese net to determine the affinities W often improves the quality of the clustering.

Siamese nets are typically trained on a collection of similar (positive) and dissimilar (negative) pairs of data points. When labeled data are available, such pairs can be chosen based on label information (i.e., pairs of points

5

Under review as a conference paper at ICLR 2018

with the same label are considered positive, while pairs of points with different labels are considered negative). Here we focus on datasets that are unlabeled. In this case we can learn the affinities directly from Euclidean proximity or from graph distance, e.g., by "labeling" points xi, xj positive if xi - xj is small and negative otherwise. In our experiments, we construct positive pairs from the nearest neighbors of each point. Negative pairs are constructed from points with larger distances. This Siamese network, therefore, is trained to learn an adaptive nearest neighbor metric.
A Siamese net maps every data point xi into an embedding zi = Gsiamese (xi) in some space. The net is typically trained to minimize contrastive loss, defined as

Lsiamese(siamese; xi, xj ) =

zi - zj 2, max (c - zi - zj , 0))2 ,

(xi, xj) is a positive pair (xi, xj) is a negative pair,

where c is a margin (typically set to 1).
Once the Siamese net is trained, we use it to define a batch affinity matrix W for the training of SpectralNet, by thresholding the distances between the embeddings, i.e., by setting Wi,j to 1 whenever zi - zj < and 0 otherwise. In our experiments we use = .25.

3.3 ALGORITHM

Our end-to-end training approach is summarized in Algorithm 1.

Input: X  Rd, number of clusters k, batch size m;

Result: embeddings y1, . . . , yn, yi  Rk, cluster assignments c1, . . . cn, ci  {1, . . . k}

Construct a training set of positive and negative pairs for the Siamese network;

Train a Siamese network;

Randomly initialize the network weights ;

while LSpectralNet() not converged do Orthogonalization step:

Sample a random minibatch X of size m;

Forward propagate X and compute inputs to orthogonalization layer Y~ ;

Compute the Cholesky factorization LLT = Y~ T Y~ ;

 Set the weights of the orthogonalization layer to be m

L-1

T;

Gradient step:

Sample a random minibatch x1, . . . , xm; Compute the m × m affinity matrix W using the Siamese net;

Forward propagate x1, . . . , xm to get y1, . . . , ym;

Compute

the

loss

LSpectralNet()

=

1 m

m i,j=1

Wi,j

yi - yj

2;

Use the gradient of LSpectralNet() to tune all F weights, except those of the output layer;

end

Forward propagate x1, . . . , xn and obtain F outputs y1, . . . , yn;

Run k-means on y1, . . . , yn to determine cluster centers;

Algorithm 1: SpectralNet training

Once SpectralNet is trained, computing the embeddings of new test points (i.e., out-of-sample-extension) and
their cluster assignments is straightforward: we simply propagate each test point xi through the network F to obtain their embeddings yi, and assign the point to its nearest centroid, where the centroids were computed using k-means on the training data, at the last line of Algorithm 1.

6

Under review as a conference paper at ICLR 2018

3.4 SPECTRAL CLUSTERING IN CODE SPACE
Given a dataset X , one can either apply SpectralNet in the original input space, or in a code space (obtained, for example, by an autoencoder). A code space representation is typically lower dimensional, and often contains less nuisance information (i.e., information on which an appropriate similarity measure should not depend). Following (Yang et al., 2017; Xie et al., 2016; Zheng et al., 2016) and others, we empirically observed that SpectralNet performs best in code space. Unlike these works, which use an autoencoder as an initialization for their clustering networks, we use the code as our data representation and apply SpectralNet directly in that space, (i.e., we do not change the code space while training SpectralNet). In our experiments, we use code spaces obtained from publicly available autoencoders trained by Zheng et al. (2016) on the MNIST and Reuters datasets.

4 THEORETICAL ANALYSIS

Our proposed SpectralNet not only determines cluster assignments in training, as clustering algorithms commonly do, but it also produces a map that can generalize to unseen data points at test time. Given a training set with n points, it is thus natural to ask for how large should such a network be to represent this spectral map. Intuitively, the answer to this question should depend on the complexity of the boundaries between the clusters. Indeed, the theory of VC-dimension can provide useful worst-case bounds for this size.

In this section, we use the VC dimension theory to study the minimal size a neural network should have in order to compute spectral clustering for k = 2. Specifically, we consider the class of functions that map all training
points to binary values, determined by thresholding at zero the eigenvector of the graph Laplacian with the second smallest eigenvalue. We denote this class of binary classifiers Fnspectral clustering. Note that with k = 2, k-means can be replaced by thresholding of the second smallest eigenvector, albeit not necessarily at zero. We are interested
in the minimal number of weights and neurons required to allow the net to compute such functions, assuming the
affinities decay exponentially with the Euclidean distance. We do so by studying the VC dimension of function classes obtained by performing spectral clustering on n points in arbitrary Euclidean spaces Rd, with d  3. We will make no assumption on the underlying distribution of the points.

In the main result of this section, we prove a lower bound on the VC dimension of spectral clustering, which is linear in the number of points n. In contrast, the VC dimension of k-means, for example, depends solely on the dimension d, but not on n, hence making k-means significantly less expressive than spectral clustering1. As a
result of our main theorem, we bound from below the number of weights and neurons in any net that is required
to compute Laplacian eigenvectors. The reader might find the analysis in this section interesting in its own right.

Our main result shows that for data in Rd with d  3, the VC dimension of Fnspectral clustering is linear in the number n of points, making spectral clustering almost as rich as arbitrary clustering of the n points.

Theorem 4.1.

VC dim(Fnspectral clustering) 

1 10

n.

The formal proof of Theorem 4.1 is deferred to Appendix C. Below we informally sketch its principles. We want to show that for any integer n (assuming for simplicity that n is divisible by 10), there exists a set of m = n/10 points in Rd that is shattered by Fnspectral clustering. In particular, we show this for the set of m points placed in a 2dimensional grid in Rd. We then show that for any arbitrary dichotomy of these m points, we can augment the set of points to a larger set X, containing n = 10m points, with a balanced partition of X into two disjoint sets S and T that respect the dichotomy of the original m points. The larger set has the special properties: (1) within S (and resp. T ), there is a path between any two points such that the distances between all pairs of consecutive points along the path are small, and (2) all pairs (s, t)  S × T are far apart. We complete the proof by constructing a Gaussian affinity W with a suitable value of  and showing that the minimizer of the spectral clustering loss

1For two clusters in Rd, k-means clustering partitions the data using a linear separation. It is well known that the VC dimension of the class of linear classifiers in Rd is d + 1. Hence, k-means can shatter at most d + 1 points in Rd, regardless of the size n of the dataset.

7

Under review as a conference paper at ICLR 2018

for (X, W ) (i.e., the second eigenvector of the Laplacian), when thresholded at 0, separates S from T , and hence also the original set of the m points.
By connecting Theorem 4.1 with known results regarding the VC dimension of neural nets, see, e.g., (ShalevShwartz & Ben-David, 2014), we can bound the size from below (in terms of number of weights and neurons) of any neural net that computes spectral clustering. This is formalized in the following corollary.
Corollary 4.2.
1. For the class of neural nets with |v| sigmoid nodes and |w| weights to represent all functions realizable by spectral clustering (i.e., second eigenvector of the Laplacian, thresholded at 0) on n points, it is necessary to have |w|2|v|2  O(n).
2. for the class of neural nets with |w| weights from a finite family (e.g., single-precision weights) to represent all functions realizable by spectral clustering, it is necessary to have |w|  O(n).
Proof.
1. The VC dimension of the class of neural nets with |v| sigmoid units and |w| weights is at most O(|w|2|v|2) (see (Shalev-Shwartz & Ben-David, 2014), p. 275). Hence, if |w|2|v|2 < O(n), such net cannot shatter any collection of points of size O(n). From Theorem 4.1, Fnspectral clustering shatters at least O(n) points. Therefore, in order for a class of networks to be able to express any function that can be computed using spectral clustering, it is a necessary (but not sufficient) condition to satisfy |w|2|v|2  O(n).
2. The VC dimension of the class of neural nets with |w| weights from a finite family is O(w) (see (ShalevShwartz & Ben-David, 2014) p. 276). The arguments above imply that |w|  O(n).

Corollary 4.2 implies that in the general case (i.e., without assuming any structure on the n data points), to perform spectral clustering, the size of the net has to grow with n. However, when the data has some geometric structure, the net size can be much smaller. Indeed, in a related result, the ability of neural networks to learn eigenvectors of Laplacian matrices was demonstrated both empirically and theoretically by Mishne et al. (2017). They proved that there exist networks which approximate the eigenfunctions of manifold Laplacians arbitrarily well (where the size of the network depends on the desired error and the parameters of the manifold, but not on n).

5 EXPERIMENTAL RESULTS

5.1 EVALUATION METRICS

To numerically evaluate the accuracy of the clustering, we use two commonly used measures, the unsupervised clustering accuracy (ACC), and the normalized mutual information (NMI). For completeness, we define ACC and NMI below, and refer the reader to (Cai et al., 2011) for more details. For data point xi, let li and ci denote its true label and predicted cluster, respectively. Let l = (l1, . . . ln) and similarly c = (c1, . . . cn).

ACC is defined as

1n

ACC(l, c) = max n 

1 {li =  (ci)} ,

i=1

where  is the collection of all permutations of {1, . . . k}. The optimal permutation  can be computed using the Kuhn-Munkres algorithm (Munkres, 1957).

8

Under review as a conference paper at ICLR 2018

Algorithm k-means Spectral clustering
DEC DCN VaDE DEPICT SpectralNet (input space, Gaussian affinity) SpectralNet (input space, Siamese affinity) SpectralNet (code space, Gaussian affinity) SpectralNet (code space, Siamese affinity)

ACC (MNIST) .534 .717
.843* .83** .9446*** .965**** .622±.008 .826±.03 .800±.003 .971±.001

NMI (MNIST) .499 .754
.8** .81** not reported .917 .687±.004 .884±.02 .814±.008 .925±.001

ACC (Reuters) .533 NA
.756* not reported .7938*** not reported .645±.01 .661± 017 .605±.053 .800±.01

NMI (Reuters) .401 NA
not reported not reported not reported not reported .444±.01 .381 ± .057 .401±.061 .531±.014

Table 1: Performance of various clustering methods on MNIST and Reuters datasets. (*) reported in (Xie et al., 2016). (**) reported in (Yang et al., 2017), (***) reported in (Zheng et al., 2016), (****) reported in (Dizaji et al., 2017).

NMI is defined as

I(l; c) NMI(l, c) = max{H(l), H(c)} ,

where I(l; c) denotes the mutual information between l and c, and H(·) denotes their entropy. Both ACC and NMI are in [0, 1], with higher values indicating better correspondence the clusters and the true labels.

5.2 CLUSTERING
We compare SpectralNet to several deep learning-based clustering approaches on two real world datasets. As a reference, we also report the performance of k-means and (standard) spectral clustering. Specifically, we compare SpectralNet to DEC (Xie et al., 2016), DCN (Yang et al., 2017), VaDE (Zheng et al., 2016), and DEPICT (Dizaji et al., 2017). We remark that both DEC, DCN, DEPICT and VaDE are deep learning methods that cluster the data in code spaces. The results for these four methods are reported in the corresponding papers. Technical details regarding the application of k-means and spectral clustering appear in Appendix D.
We considered two variants of SpectralNet: using Gaussian affinity (5), and Siamese net affinity; the latter case follows Algorithm 1. In addition, we report results of SpectralNet (and the Siamese net) in both input space and code space. The code spaces are obtained using the publicly available autoencoders which are used to pre-train the weights of VaDE2, and are 10-dimensional. We refer the reader to Appendix D for technical details about the architectures and training procedures.

5.2.1 MNIST
MNIST is a collection of 70,000 28 × 28 gray-scale images of handwritten digits, divided to training (60,000) and test (10,000) sets. To construct positive pairs for the Siamese net, we paired each instance with its two nearest neighbors. An equal number of negative pairs were chosen randomly from non-neighboring points.
Table 1 shows the performance of the various clustering algorithms on the MNIST dataset, using all 70,000 images for training. As can be seen, the performance of SpectralNet is significantly improved when using Siamese architecture instead of Gaussian affinity, and when the data is represented in code space rather than in pixel space. With these two components, SpectralNet outperforms all other methods.
To evaluate how well the outputs of SpectralNet approximate the true eigenvectors of the graph Laplacian, we compute the Grassmann distance between the subspace of SpectralNet outputs and that of the true eigenvectors. The squared Grassmann distance measures the sum of squared sines of the angles between two k-dimensional
2https://github.com/slim1017/VaDE/tree/master/pretrain_weights

9

Under review as a conference paper at ICLR 2018
subspaces; the distance is in [0, k]. Figure 2 shows the Grassmann distance on the MNIST dataset as a function of the training time (expressed as number of parameter updates). It can be seen that the distance decreases rapidly at the beginning of training and stabilizes around 0.18 as time progresses.
To check the generalization ability of SpectralNet to new test points, we repeated the experiment, this time training SpectralNet only on the training set, and predicting the labels of the test examples by passing them through the net and associating each test example with the nearest centroid from the k-means that were performed on the embedding of the training examples. The accuracy on test examples was .972, implying that SpectralNet generalizes well to unseen test data in this case,
5.2.2 REUTERS
The Reuters dataset is a collection of English news, labeled by category. Like DEC and VaDE, we used the following categories: corporate/industrial, Figure 2: Grassmann distance as government/social, markets, and economics as labels and discarded all doc- a function of iteration update for uments with multiple labels. Each article is represented by a tf-idf vector, the MNIST dataset. using the 2000 most frequent words. The dataset contains n = 685, 071 documents. Performing vanilla spectral clustering on a dataset of this size in a standard way is prohibitive. The AE used to map the data to code space was trained based on a random subset of 10,000 samples from the full dataset. To construct positive pairs for the Siamese net, we randomly sampled 300,000 examples from the entire dataset, and paired each one with a random neighbor from its 3000 nearest neighbors. An equal number of negative pairs was obtained by randomly pairing each point with one of the remaining points.
Table 1 shows the performance of the various algorithms on the Reuters dataset. Overall, we see similar behavior to what we observed on MNIST: SpectralNet outperforms all other methods, and performs best in code space, and using Siamese affinity.
To evaluate the generalization ability of SpectralNet, we divided the data randomly to a 90%-10% split, re-trained the autoencoder, Siamese net and SpectralNet on the larger subset, and predicted the labels of the smaller subset. The test accuracy was 0.799, implying that as on MNIST, SpectralNet generalizes well to new examples.
6 CONCLUSIONS
We have introduced SpectralNet, a deep learning approach for approximate spectral clustering. The stochastic training of SpectralNet allows us to scale to larger datasets than what vanilla spectral clustering can handle, and the parametric map obtained from the net enables straightforward out of sample extension. In addition, we propose to use unsupervised Siamese networks to compute affinities, and empirically show that this results in better performance, comparing to standard Gaussian affinities. Further improvement are achieved by applying our network to code representations produced with a standard stacked autoencoder. We present a novel analysis of the VC dimension of spectral clustering, and derive a lower bound on the size of neural nets that compute it. In addition, we report state of the art results on two benchmark datasets, and show that SpectralNet outperforms existing methods when the clusters cannot be contained in non overlapping convex shapes. We believe the integration of spectral clustering with deep learning provides a useful tool for unsupervised deep learning.
REFERENCES
Yoshua Bengio, Jean-franc¸cois Paiement, Pascal Vincent, Olivier Delalleau, Nicolas L Roux, and Marie Ouimet. Out-of-sample extensions for lle, isomap, mds, eigenmaps, and spectral clustering. In Advances in neural information processing systems, pp. 177­184, 2004.
10

Under review as a conference paper at ICLR 2018
Deng Cai, Xiaofei He, and Jiawei Han. Locally consistent concept factorization for document clustering. IEEE Transactions on Knowledge and Data Engineering, 23(6):902­913, 2011.
Gang Chen. Deep learning with nonparametric clustering. arXiv preprint arXiv:1501.03084, 2015.
Ronald R Coifman and Ste´phane Lafon. Diffusion maps. Applied and computational harmonic analysis, 21(1): 5­30, 2006a.
Ronald R Coifman and Ste´phane Lafon. Geometric harmonics: a novel tool for multiscale out-of-sample extension of empirical functions. Applied and Computational Harmonic Analysis, 21(1):31­52, 2006b.
Nat Dilokthanakul, Pedro AM Mediano, Marta Garnelo, Matthew CH Lee, Hugh Salimbeni, Kai Arulkumaran, and Murray Shanahan. Deep unsupervised clustering with gaussian mixture variational autoencoders. arXiv preprint arXiv:1611.02648, 2016.
Kamran Ghasedi Dizaji, Amirhossein Herandi, and Heng Huang. Deep clustering via joint convolutional autoencoder embedding and relative entropy minimization. arXiv preprint arXiv:1704.06327, 2017.
Charless Fowlkes, Serge Belongie, Fan Chung, and Jitendra Malik. Spectral grouping using the nystrom method. IEEE transactions on pattern analysis and machine intelligence, 26(2):214­225, 2004.
Raia Hadsell, Sumit Chopra, and Yann LeCun. Dimensionality reduction by learning an invariant mapping. In Computer vision and pattern recognition, 2006 IEEE computer society conference on, volume 2, pp. 1735­ 1742. IEEE, 2006.
Marc T Law, Raquel Urtasun, and Richard S Zemel. Deep spectral clustering learning. In International Conference on Machine Learning, pp. 1985­1994, 2017.
Gal Mishne, Uri Shaham, Alexander Cloninger, and Israel Cohen. Diffusion nets. Applied and Computational Harmonic Analysis, 2017.
James Munkres. Algorithms for the assignment and transportation problems. Journal of the society for industrial and applied mathematics, 5(1):32­38, 1957.
Boaz Nadler, Stephane Lafon, Ioannis Kevrekidis, and Ronald R Coifman. Diffusion maps, spectral clustering and eigenfunctions of fokker-planck operators. In Advances in neural information processing systems, pp. 955­962, 2006.
Andrew Y Ng, Michael I Jordan, and Yair Weiss. On spectral clustering: Analysis and an algorithm. In Advances in neural information processing systems, pp. 849­856, 2002.
Shai Shalev-Shwartz and Shai Ben-David. Understanding machine learning: From theory to algorithms. Cambridge university press, 2014.
Ohad Shamir. A stochastic pca and svd algorithm with an exponential convergence rate. In Proceedings of the 32nd International Conference on Machine Learning (ICML-15), pp. 144­152, 2015.
Jianbo Shi and Jitendra Malik. Normalized cuts and image segmentation. IEEE Transactions on pattern analysis and machine intelligence, 22(8):888­905, 2000.
Fei Tian, Bin Gao, Qing Cui, Enhong Chen, and Tie-Yan Liu. Learning deep representations for graph clustering. In AAAI, pp. 1293­1299, 2014.
Ulrike Von Luxburg. A tutorial on spectral clustering. Statistics and computing, 17(4):395­416, 2007.
Junyuan Xie, Ross Girshick, and Ali Farhadi. Unsupervised deep embedding for clustering analysis. In International Conference on Machine Learning (ICML), 2016.
11

Under review as a conference paper at ICLR 2018 Bo Yang, Xiao Fu, Nicholas D Sidiropoulos, and Mingyi Hong. Towards k-means-friendly spaces: Simultaneous
deep learning and clustering. International Conference on Machine Learning (ICML), 2017. Jianwei Yang, Devi Parikh, and Dhruv Batra. Joint unsupervised learning of deep representations and image
clusters. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pp. 5147­5156, 2016. Li Yi, Hao Su, Xingwen Guo, and Leonidas Guibas. Syncspeccnn: Synchronized spectral cnn for 3d shape segmentation. arXiv preprint arXiv:1612.00606, 2016. Yin Zheng, Huachun Tan, Bangsheng Tang, Hanning Zhou, et al. Variational deep embedding: A generative approach to clustering. arXiv preprint arXiv:1611.05148, 2016.
12

Under review as a conference paper at ICLR 2018

Figure 3: SpectralNet performance on the nested `C' example. Top row: clustering using SpectralNet (left), spectral clustering (center), and k-means (right). Bottom row, left panel: SpectralNet outputs (plotted in blue and green) vs. the true eigenvectors. Bottom row, right panel: loss and Grassmann distance as a function of iteration number; the values on the horizontal axis ×100 are the numbers of the parameter updates.

A ILLUSTRATIVE DATASETS

To compare SpectralNet to spectral clustering, we consider a simple dataset of 1500 points in two dimen-

sions, containing two nested `C'. We applied spectral clustering to the dataset by computing the eigenvectors

of the unnormalized graph Laplacian L = D - W corresponding to the two smallest eigenvalues, and then

applying k-means (with k=2) to these eigenvector embeddings. The affinity matrix W was computed using

Wi,j = exp

- xi-xj 2
2

, where the scale  was set to be the median distance between a point to its 3rd

neighbor ­ a standard practice in diffusion applications.

Figure 3 shows the clustering of the data obtained by SpectralNet, standard spectral clustering, and k-means. It can be seen that both SpectralNet and spectral clustering identify the correct cluster structure, while k-means fails to do so. Moreover, despite the stochastic training, the net outputs closely approximate the two true eigenvectors of W with smallest eigenvalues. Indeed the Grassmann distance between the net outputs and the true eigenvectors approaches zero as the loss decreases.

In the next experiment, we trained, DCN, VaDE , and DEPICT (using agglomerative clustering initialization) on the 2D datasets of Figure 1. The experiments were performed using the code published by the authors of each paper. For each method, we tested various network architectures and hyper-parameter settings. Unfortunately, for each method and any of the datasets, we were unable to find a setting that will yield an appropriate clustering. Plots with typical results of each of the methods on each of the five 2D datasets is shown in Figure 4.

To further investigate why these methods fail, we performed a sequence of experiments with the two nested 'C's data, while changing the distance between the two clusters. The results are shown in Figure 5. We can see that all three methods fail to cluster the points correctly once the clusters cannot be separated using non-overlapping convex shapes.

Interestingly, although the target distribution of DEPICT was initialized with agglomerative clustering, which successfully clusters the nested 'C's, its target distribution becomes corrupted throughout the training, although its loss is considerably reduced, see Figure 6.

13

Under review as a conference paper at ICLR 2018
Figure 4: Results of DCN (top), VaDE (middle) and DEPICT (bottom) on our illustrative datasets.
Figure 5: Typical results of DCN (top row), VaDE (center row) and DEPICT (bottom row) on the nested 'C's, with several different distances between the two clusters.
14

Under review as a conference paper at ICLR 2018
Figure 6: The nested 'C's, colored by DEPICT target distribution. Left: at initialization (with agglomerative clustering initialization). the DEPICT loss at this stage is 9.01. Right: after DEPICT training. The loss is 0.22. Although the loss decreases with training, the target distribution becomes corrupted.
B CORRECTNESS OF THE QR DECOMPOSITION
We next verify that the Cholesky decomposition can indeed be used to compute the QR decomposition of a positive definite matrix. First, observe that since L is lower triangular, then so is L-1, and (L-1)T is upper triangular. Hence for i = 1, . . . m, the column space of the first i columns of A is the same as the column space of the first i columns of Q = A(L-1)T . To show that the columns of Q corresponds to Gram-Schmidt orthogonalization of the columns of A, it therefore remains to show that QT Q = I. Indeed:
QT Q = L-1AT A(L-1)T = L-1LLT (L-1)T = (L-1L)T = I.
C SECTION 4 PROOFS
C.1 PRELIMINARIES To prove Theorem 4.1, we begin with the following definition and lemmas. Definition C.1 ((, )-separated graph). Let  >   0. An (, )-separated graph is G = (V, W ), where V has an even number of vertices and has a balanced partition V = S  T , |S| = |T |, and W is an affinity matrix so that:
· For any vi, vj  S (resp. T ), there is a path vi = vk1 , vk2 , . . . , vkl = vj  S, so that for every two consecutive points vkl , vkl+1 along the path, Wkl,kl+1  .
· For any vi  S, vj  T , Wi,j  . Lemma C.2. For any integer m > 0 there exists a set X~ = {x1, . . . , xm}  Rd (d  3), so that for any binary partition X~ = S~  T~, we can construct a set X of n = 10m points, X~  X, and a balanced binary partition X = S  T , |S| = |T | of it, such that
· S~  S, T~  T · For any xi, xj  S (resp. T ), there is a path xi, xk1 , xk2 , . . . , xkl , xj  S, so that for every two
consecutive points xkl , xkl+1 along the path, xkl - xkl+1 < 1 (property a). · For any xi  S, xj  T , xi - xj|  1(property b). Proof. We will prove this for the case d = 3; the proof holds for any d  3. Let m > 0 be integer. We choose the set X~ to lie in a 2-dimensional unit grid inside a square of minimal diameter, which is placed in the Z = 0 plane. Each point xi is at a distance 1 from its neighbors.
15

Under review as a conference paper at ICLR 2018
Figure 7: Illustration of the construction of Lemma C.2. We select the set X~ to lie in a grid in the Z = 0 plane. Given an arbitrary dichotomy X~ = S~  T~ (points are marked with filled circles, colored respectively in red and blue), we first add points to make the sets balanced (not shown). Next, we make a copy for S at Z = 1 and for T at Z = -1 (filled squares). We then add midpoints between each point and its copy (empty circles), and finally add more points along the minimal length spanning tree (empty squares). Together, all the red points form the set S; the blue points form the set T , and X = S  T .
Next, given a partition of x1, . . . , xm to two subsets, S~ and T~, we will construct a set X  X~ with n = 10m points and a partition S  T that satisfy the conditions of the lemma (an illustration can be seen in Figure 7). First, we add points to obtain a balanced partition. We do so by adding m new points xm+1, . . . , x2m, assigning each of them arbitrarily to either S~ or T~ until |S~| = |T~| = m. We place all these points also in grid points in the Z = 0 plane so that all 2m points lie inside a square of minimal diameter. We further add all the points in S~ to S and those in T~ to T . In the next step, we prepare a copy of the S~-points at Z = 1 (with the same X, Y coordinates) and a copy of the T~-points at Z = -1. We denote these copies by x1, ..., x2m and refer to the lifted points at Z = 1 by S and at Z = -1 by T . Next, we will add 6m more points to make the full set of n = 10m points satisfy properties a and b. First, we will add the midpoint between every point and its copy, i.e., xi = (xi + xi)/2. We assign each such midpoint to S (resp. T ) if it is placed between xi  S and xi  S (resp. T and T ). Then we connect the points in S (resp. T ) by a minimal length spanning tree and add 4m more points along the edges of these two spanning trees so that the added points are equally spaced along every edge. We assign the new points on the spanning tree of S to S and of T to T . We argue that the obtained point set X of size 10m satisfies the conditions of the lemma. Clearly, S~  S and T~  T . To show that property a is satisfied, note that the length of each spanning tree cannot exceed 2m, since the full 2m grid points X~ can be connected with a tree of length 2m - 1. It is evident therefore that every two points xi, xj  S (resp. T ) are connected by a path in which the distance between each two consecutive points is strictly less than 1 (property a). Property b too is satisfied because the grid points in X~ are at least distance 1 apart; each midpoint xi is distance 1/2 from xi and xi (and they all belong to the same set, either S or T ), but its distance to the rest of the points in X~ exceeds 1, and the rest of the points in S (resp. T ) are on the Z = 1 (resp. Z = 1) plane, and so they are at least distance 1 away from members of the opposite set which all lie in the Z  0 (resp. Z  0) half space.
Lemma C.3. . Let f (·) be the spectral clustering loss
f (y) = Wi,j (yi - yj )2.
i,j
16

Under review as a conference paper at ICLR 2018

Let G = (X, W ) be a (,)-separated graph, such that |X| = n  4. Let y be a minimizer of f (y) w.r.t W , subject to 1T y = 0, y = 1. Let

S = max{yi - yj : xi, xj  S},

and similarly

T = max{yi - yj : xi, xj  T }.

Let  = max {S, T }. Then

 2



n2 .

2

Proof.

y


n

and

2

Without

yn 2

+1



loss of

y


n 2

+2

generality,  . . .  yn

assume that . Also wlog,

x1 

,.. =

.,xn  2
S. We

S,

x

n 2

+1

begin by

, . . . , xn  T , and that lower-bounding f (y).

y1



y2



...



f (y) = Wi,j (yi - yj)2

i,j

 Wi,j (yi - yj)2 + Wi,j (yi - yj)2.

xi,xj S

xi,xj T

Since

G

is (, )-separated, there

exists

a path from

y1

to y n 2

(and likewise

from

y

n 2

+1

to yn) where

the affinity

of every pair of consecutive points exceeds . Denote this path by S (resp. T ), therefore



f (y)   

(yki+1 - yki )2 +

(yki+1 - yki )2 .

xki ,xki+1 S

xki ,xki+1 T

Note that these are telescopic sums of squares. Clearly, such sum of squares is minimized if all n/2 points are ordered and equi-distant, i.e., if we divide a segment of length  into n/2 - 1 segments of equal length.
Consequently, discarding the second summand,

f (y)   n - 1



2

=

22



22 ,

2

n/2 - 1

n-2 n

Next, to produce an upper bound, we consider the vector y¯

=

1 n

(-1,

.

.

.

,

-1,

1,

.

.

.

1),

i.e.,

y¯i

=

-

1 n

for

i



n 2

,

and

1 n

otherwise.

For

this

vector,

f (y¯)   n 2 2

2
= n.

2n

In summary, we obtain Hence

22  f (y)  f (y¯)  n, n

 2



n2 .

2

Lemma C.4. Let y  Rn be a vector such that 1T y = 0, and

y

=

1.

Let

X

=

S



T,

|S|

=

|T |

=

n 2

.

S = max{yi - yj : xi, xj  S},

and similarly

T = max{yi - yj : xi, xj  T }.

Let



=

max {S, T }.

If



<

1 ,
2n

then

max{yi : xi  S} < 0 < min{yi : xi  T }.

17

Under review as a conference paper at ICLR 2018

Proof. Let

22

mS = n

yi, mT = n

yi.

xi S

xi T

Since 1T y = 0, we have mS = -mT . Without loss of generality, assume that mS < 0 < mT . For every yi such

that xi  S,

(yi - mS)2  2.

(6)

Similarly, for every yi such that xi  T ,

(yi + mS)2 = (yi - mT )2  2.

This gives

n2  (yi - mS)2 + (yi + mS)2

xi S

xi T

=

yi2 - 2mS

yi + 2mS

yi + nm2S

xi S T

xi S

xi T

=

1

-

2mS

·

mS

n 2

+

2mS

·

-mS

n 2

+

nmS2

= 1 - nmS2 ,

which gives

m2S



1

- n2 .
n

In order to obtain the desired result, i.e., that max{yi : xi  S} < 0 < min{yi : xi  T }, it therefore remains to show that for a sufficiently small , by (6), mS +  < 0 (this will also yield mT -  > 0). Hence, we will
require 1 - n2  2, n

which holds for  < 1 .
2n

C.2 PROOF OF THEOREM 4.1

Proof. To determine the VC-dimension of Fnspectral clustering we need to show that there exists a set of m = n/10
points (assuming for simplicity that n is divisible by 10) that is shattered by spectral clustering. By Lemma C.2, there exists a set of m points X~  Rd (d  3) so that for any dichotomy of X~ there exists a set X  X~ of n = 10m points, with a balanced partition X = S  T that respects the dichotomy of X~ , and whose points satisfy
properties a and b of Lemma C.2 with 0  b < a = 1.

Consider next the complete graph G = (V, W ) whose vertices vi  V correspond to point xi and the affinity

matrix W is set with the standard Gaussian affinity Wi,j = exp

- xi-xj 2
22

, where the value of  will be

provided below. It can be readily verified that, due to properties a and b, G is (, )-separated, where

b2 1  = exp - 22 ,  = exp - 22 . .
Let y be the second-smallest eigenvector of the graph Laplacian matrix for G, i.e., the minimizer of

f (y) = Wi,j(yi - yj)2, s.t. 1T y = 0, yT y = 1.
i,j

18

Under review as a conference paper at ICLR 2018

Code space
Input space Input space

Siamese net
ReLU, size = 2000 ReLU, size = 500 ReLU, size = 10 flattening ReLU, size = 2048 ReLU, size = 2048 ReLU, size = 512 ReLU, size = 10 -

SpectralNet
ReLU, size = 2000 ReLU, size = 500 tanh, size = 10 orthonorm flattening ReLU, size = 2048 ReLU, size = 2048 ReLU, size = 512 tanh, size = 10 orthonorm

Table 2: Siamese net and SpectralNet architecture in the MNIST experiment.

Siamese net
SELU, size = 2048 SELU, size = 512 SELU, size = 256 SELU, size = 128 -

SpectralNet
ReLU, size = 2048 ReLU, size = 512 ReLU, size = 256 tanh, size = 4 orthonorm

Table 3: Siamese net and SpectralNet architecture in the Reuters experiment. The same architecture was used for both input and code spaces.

By Lemma C.3, since G is (, )-separated, , i.e, the spread of the entries of y for the partition S  T , should

satisfy

 2



n2 .

2

Notice that

 1 - b2

= exp 

22

,

allowing us to make  arbitrarily small by pushing the scale  towards 03. In particular, we can set  so as to make  satisfy  < 1/ 2n. Therefore, by lemma (C.4), thresholding y at 0 respects the partition of X, and hence also the dichotomy of X~ .

In summary, we have shown that any dichotomy of X~ can be obtained from a second-smallest eigenvector of some graph Laplacian of n points. Hence the VC dimension of F is at least m = n/10.

D TECHNICAL DETAILS

For k-means we used Python's sklearn.cluster; we used the default configuration (in particular, 300 iterations of

the algorithm, 10 restarts from different centroid seeds, final results are from the run with the best objective).

To perform spectral clustering, we computed an affinity matrix W using (5), with the number of neighbors set

to 25 and the scale  set to the median distance from any point its 25th neighbor. Once W was computed, we

computed the k eigenvectors of D - W corresponding to the smallest eigenvalues, and then applied k-means to

that embedding. The k-means configuration was as above. In our experiments, the loss (3) was computed with

a

factor

of

1 m

rather

than

1 m2

,

for

numerical

stability.

The

architectures

of

the

Siamese

net

and

SpectralNet

are

described in Tables 2 and 3. Additional technical details are shown in Table 4.

In the MNIST experiments, the training set for the Siamese was obtained by pairing each data point with its two nearest neighbors. In the Reuters experiment, we obtained the training set for the Siamese net by selecting a

3We note that Theorem 4.1 also holds with constant , in which case we can instead uniformly scale the point locations of X~ and respectively X.

19

Under review as a conference paper at ICLR 2018

Batch size Ortho. batch size Initial LR LR decay Decay every Optimizer Margin

MNIST Siamese
128 10-3 .98 1 epoch RMSprop -

MNIST SpectralNet
512 512 10-3 .98 100 updates RMSprop .25

Reuters Siamese
128 10-3 .98 1 epoch RMSprop -

Reuters SpectralNet
128 512 10-4 .98 100 updates RMSprop .4

Table 4: Additional technical details.

random subset of 100,000 points and pairing each point from that set to a random point from its 3,000 nearest neighbors. To evaluate the generalization performance, as well as in the semi supervised experiments, the Siamese nets were trained using training data only. The Siamese nets were trained until the loss on a validation set (a random subset of the training set) converged. The SpectralNets were trained until the training loss converged. Typical training took about 220 epochs for a Siamese net and 50,000 parameter updates for SpectralNet.

20

