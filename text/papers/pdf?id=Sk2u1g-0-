Under review as a conference paper at ICLR 2018
CONTINUOUS ADAPTATION VIA META-LEARNING IN NONSTATIONARY AND COMPETITIVE ENVIRONMENTS
Anonymous authors Paper under double-blind review
ABSTRACT
Ability to continuously learn and adapt from limited experience in nonstationary environments is an important milestone on the path towards general intelligence. In this paper, we cast the problem of continuous adaptation into the learning-to-learn framework. We develop a simple gradient-based meta-learning algorithm suitable for adaptation in dynamically changing and adversarial scenarios. Additionally, we design a new multi-agent competitive environment, RoboSumo, and define iterated adaptation games for testing various aspects of continuous adaptation. We demonstrate that meta-learning enables significantly more efficient adaptation than reactive baselines in the few-shot regime. Our experiments with a population of agents that learn and compete suggest that meta-learners are the fittest.
1 INTRODUCTION
Recent progress in reinforcement learning (RL) has achieved very impressive results ranging from playing games (Mnih et al., 2015; Silver et al., 2016), to applications in dialogue systems (Li et al., 2016), to robotics (Levine et al., 2016). Despite the progress, the learning algorithms for solving many of these tasks are designed to deal with stationary environments. On the other hand, real-world is often nonstationary either due to complexity (Sutton et al., 2007), changes in the dynamics or the objectives in the environment over the life-time of a system (Thrun, 1998), or presence of multiple learning actors (Lowe et al., 2017). Nonstationarity breaks the standard assumptions and requires agents to continuously adapt, both at training and execution time, in order to succeed.
Learning under nonstationary conditions is challenging. The classical approaches to dealing with nonstationarity are usually based on context detection (Da Silva et al., 2006) and tracking (Sutton et al., 2007), i.e., reacting to the already happened changes in the environment by continuously fine-tuning the policy. Unfortunately, modern deep RL algorithms, while able to achieve super-human performance on certain tasks, are known to be sample inefficient. Nevertheless, nonstationarity allows only for limited interaction before the properties of the environment change. Thus, it immediately puts learning into the few-shot regime and often renders simple fine-tuning methods impractical.
A nonstationary environment can be seen as a sequence of stationary tasks, and hence we propose to tackle it as a multi-task learning problem (Caruana, 1998). The learning-to-learn (or meta-learning) approaches (Schmidhuber, 1987; Thrun & Pratt, 1998) are particularly appealing in the few-shot regime, as they produce flexible learning rules that can generalize from only a handful of examples. Meta-learning has shown promising results in the supervised domain and have gained a lot of attention from the research community recently (e.g., Santoro et al., 2016; Ravi & Larochelle, 2016). In this paper, we develop a gradient-based meta-learning algorithm similar to (Finn et al., 2017b) and suitable for continuous adaptation of RL agents in nonstationary environments. More concretely, our agents meta-learn to anticipate the changes in the environment and update their policies accordingly.
While virtually any changes in an environment could induce some kind of nonstationarity (e.g., changes in the physics or characteristics of the agent), environments with multiple agents are particularly challenging due to complexity of the emergent behavior and are of practical interest with applications ranging from multiplayer games (Peng et al., 2017) to coordinating self-driving fleets Cao et al. (2013). Multi-agent environments are nonstationary from the perspective of any individual agent since all actors are learning and changing concurrently (Lowe et al., 2017; Foerster et al., 2017a). In this paper, we consider the problem of continuous adaptation to a learning opponent in a competitive multi-agent setting.
1

Under review as a conference paper at ICLR 2018
To this end, we design RoboSumo--a 3D environment with simulated physics that allows pairs of agents to compete against each other. To test continuous adaptation, we introduce iterated adaptation games--a new setting where a trained agent competes against the same opponent for multiple rounds of a repeated game, while both are allowed to update their policies and change their behaviors between the rounds. In such iterated games, from the agent's perspective, the environment changes from round to round, and the agent ought to adapt in order to win the game. Additionally, the competitive component of the environment makes it not only nonstationary but also adversarial, which provides a natural training curriculum and encourages learning robust strategies (Bansal et al., 2017).
We evaluate our meta-learning agents along with a number of baselines on a (single-agent) locomotion task with handcrafted nonstationarity and on iterated adaptation games in RoboSumo. Our results demonstrate that meta-learned strategies clearly dominate other adaptation methods in the few-shot regime in both single- and multi-agent settings. Finally, we carry out a large-scale experiment where we train a diverse population of agents with different morphologies, policy architectures, and adaptation methods, and make them interact by competing against each other in iterated games. We evaluate the agents based on their TrueSkills (Herbrich et al., 2007) in these games, as well as evolve the population as whole for a few generations--the agents that lose disappear, while the winners get duplicated. Our results suggest that the agents with meta-learned adaptation strategies end up being the fittest. Videos that demonstrate adaptation behaviors in different tasks are available at https://goo.gl/tboqaN.
2 RELATED WORK
The problem of continuous adaptation considered in this work is related to continual or lifelong (Thrun & Pratt, 1998; Silver et al., 2013) and never-ending (Mitchell et al., 2015) learning problems. Life-long learning systems aim at solving multiple tasks sequentially by efficiently transferring and utilizing knowledge from already learned tasks to the new ones while minimizing the effect of catastrophic forgetting (McCloskey & Cohen, 1989). Never-ending learning is concerned with mastering a fixed set of tasks in iterations such that the set keeps growing and the performance on all the tasks in the set keeps improving from iteration to iteration.
The scope of continuous adaptation is narrower and more precise. While life-long and never-ending learning settings are defined as general multi-task problems (Silver et al., 2013; Mitchell et al., 2015), continuous adaptation targets to solve a single but nonstationary task or environment. The nonstationarity in the former two problems exists and is dictated by the selected sequence of tasks. In the latter case, we assume that nonstationarity is caused by some underlying dynamics in the properties of a given task in the first place (e.g., changes in the behavior of other agents in a multiagent setting). Finally, in the life-long and never-ending scenarios the boundary between training and execution is blurred as such systems constantly operate in the training regime. Continuous adaptation, on the other hand, expects a (potentially trained) agent to adapt to the changes in the environment at execution time under the pressure of limited data or interaction experience between the changes1.
Nonstationarity of multi-agent environments is a well known issue that has been extensively studied in the context of learning in simple multi-player iterated games (such as rock-paper-scissors) where each episode is one-shot interaction (Singh et al., 2000; Bowling, 2005; Conitzer & Sandholm, 2007). In such games, discovering and converging to a Nash equilibrium strategy is a success for the learning agents. Modeling and exploiting opponents (Zhang & Lesser, 2010; Mealing & Shapiro, 2013) or event their learning processes (Foerster et al., 2017b) is advantageous as it improves convergence or helps to discover equilibria of certain properties (e.g., leads to cooperative behavior). In contrast, each episode in RoboSumo consists of multiple steps, happens in continuous time, and requires learning a good intra-episodic controller. Finding Nash equilibria in such setting is hard. Thus, fast adaptation becomes one of the few viable strategies against changing opponents.
Our proposed method for continuous adaptation follows the general meta-learning paradigm (Schmidhuber, 1987; Thrun & Pratt, 1998), i.e., it learns a high-level procedure that can be used to generate a good policy each time the environment changes. There is a wealth of work on meta-learning, including methods for learning update rules for neural models that were explored in the past (Bengio et al.,
1The limited interaction aspect of continuous adaptation makes the problem somewhat similar to the recently proposed life-long few-shot learning (Finn et al., 2017a).
2

Under review as a conference paper at ICLR 2018

Intermediate steps

  

. . . i-1

i

i+1

...

i-1 i i+1

Policy + +

Loss Trajectory

T

. . . Ti-1

Ti

Ti+1

...

deterministic stochastic

gradient

(a) (b)

(c)

Fig. 1: (a) A probabilistic model for MAML in a multi-task RL setting. The task, T , the policies, , and the trajectories,  , are all random variables with dependencies encoded in the edges of the given graph. (b) Our extended model suitable for continuous adaptation to a task changing dynamically due to non-stationarity of the environment. Policy and trajectories at a previous step are used to construct a new policy for the current step. (c) Computation graph for the meta-update from i to i+1. Boxes represent replicas of the policy graphs with the specified parameters. The model is optimized via truncated backpropagation through time starting from LTi+1 .

1990; 1992; Schmidhuber, 1992), and more recent approaches that focused on learning optimizers for deep networks (Hochreiter et al., 2001; Andrychowicz et al., 2016; Li & Malik, 2016; Ravi & Larochelle, 2016), generating model parameters (Ha et al., 2016; Edwards & Storkey, 2016), learning task embeddings (Vinyals et al., 2016; Snell et al., 2017) including memory-based approaches (Santoro et al., 2016), learning to learn implicitly via RL (Wang et al., 2016; Duan et al., 2016), or simply learning a good initialization in a model-agnostic fashion (Finn et al., 2017b).

3 METHOD

The problem of continuous adaptation in nonstationary environments immediately puts learning into the few-shot regime: the agent must learn from only limited amount of experience that it can collect before its environment changes. Therefore, we build our method upon the previous work on gradient-based model-agnostic meta-learning (MAML) that has been shown successful in the fewshot settings (Finn et al., 2017b). In this section, we re-derive MAML for multi-task reinforcement learning from a probabilistic perspective, and then extend it to dynamically changing tasks.

3.1 A PROBABILISTIC VIEW OF MODEL-AGNOSTIC META-LEARNING (MAML)

Assume that we are given a distribution over tasks, D(T ), where each task, T , is a tuple:

T := (LT , PT (x) , PT (xt+1 | xt, at) , H)

(1)

LT is a task-specific loss function that maps a trajectory,  := (x0, a1, x1, r1, . . . , aH , xH , rH )  T ,

to a loss value, i.e., LT : T  R; PT (x) and PT (xt+1 | xt, at) define the Markovian dynamics of

the environment in task T ; H denotes the horizon; observations, xt, and actions, at, are elements

(typically, vectors) of the observation space, X , and action space, A, respectively. The loss of a

trajectory,  , is the negative cumulative reward, LT ( ) := -

H t=1

RT

(xt,

at

).

The goal of meta-learning is to find a procedure which, given access to a limited experience on a
task sampled from D(T ), can produce a good policy for solving it. More formally, after querying K trajectories from a task T  D(T ) under policy , denoted 1:K , we would like to construct a new, task-specific policy, , that would minimize the expected subsequent loss on the task T . In particular, MAML constructs parameters of the task-specific policy, , using gradient of LT w.r.t. :

 :=  - LT

1:K

, where LT

1:K

:= 1 K

K
LT (k), and k  PT ( | )

k=1

(2)

We call (2) the meta-gradient update with a meta-gradient step . The meta-update is parametrized by , which we optimize by minimizing the expected loss over the distribution of tasks, D(T ):

min ET D(T )


[RT ()] ,

where

RT ()

:=

E1:K PT ( |)

EPT ( |)

LT () | 1:K , 

(3)

where  and  are trajectories obtained under  and , respectively.

3

Under review as a conference paper at ICLR 2018

Algorithm 1 Meta-learning at training time.
input Distribution over pairs of tasks, P(Ti, Ti+1), learning rate, .
1: Randomly initialize  and . 2: repeat 3: Sample a batch of task pairs, {(Ti, Ti+1)}ni=1. 4: for all task pairs (Ti, Ti+1) in the batch do 5: Sample traj. 1:K from Ti using . 6: Compute  = (1:K , , ) as given in (7). 7: Sample traj.  from Ti+1 using . 8: end for 9: Construct RT (, ) and RT (, ) us-
ing 1:K and  as given in (8). 10: Update    + RT (, ). 11: Update    + RT (, ). 12: until Convergence output Optimal  and .

Algorithm 2 Adaptation at execution time. input A stream of tasks, T1, T2, T3, . . . . 1: Initialize  = . 2: while there are new incoming tasks do 3: Get a new task, Ti, from the stream. 4: Solve Ti using  policy. 5: While solving Ti, collect trajectories, 1(:iK) . 6: Update   (1(:iK) , , ) using
importance-corrected meta-update as in (9). 7: end while
Policy parameter space

In general, we can think of the task, trajectories, and policies, as random variables (Fig. 1a), where 

is generated from some conditional distribution PT ( | , 1:k). The meta-update (2) is equivalent

to assuming the delta distribution, PT ( | , 1:k) := 



-



1 K

K k=1

L(k

)

.

To optimize

(3), we can use the policy gradient method (Williams, 1992), where the gradient of RT () takes the

following form:

K

RT () = E1:K PT ( |) LT ()  log () + 

log (k)

PT ( |)

k=1

(4)

The expected loss on a task, RT , can be optimized with trust-region policy (TRPO) (Schulman et al., 2015a) or proximal policy (PPO) (Schulman et al., 2017) optimization methods. For details and
derivations please refer to Appendix A.

3.2 CONTINUOUS ADAPTATION VIA META-LEARNING

In the classical multi-task setting, we make no assumptions about the distribution of tasks, D(T ). When the environment is nonstationary, we can see it as a sequence of stationary tasks on a certain timescale where the tasks correspond to different dynamics of the environment. Then, D(T ) is defined by the environment changes, and the tasks become sequentially dependent. Hence, we would like to exploit this dependence between consecutive tasks and meta-learn a rule that keeps updating the policy in a way that minimizes the total expected loss encountered during the interaction with the changing environment. For instance, in the multi-agent setting, when playing against an opponent that changes its strategy incrementally (e.g., due to learning), our agent should ideally meta-learn to anticipate the changes and update its policy accordingly.

In the probabilistic language, our nonstationary environment is equivalent to a distribution of tasks represented by a Markov chain (Fig. 1b). The goal is to minimize the expected loss over the chain of tasks of some length L:

min


EP

(T0

),P

(Ti+1

|Ti

)

L
RTi,Ti+1 ()
i=1

(5)

Here, P(T0) and P(Ti+1 | Ti) denote the initial and the transition probabilities in the Markov chain of tasks. Note that (i) we deal with Markovian dynamics on two levels of hierarchy, where the upper
level is the dynamics of the tasks and the lower level is the MDPs that represent particular tasks, and (ii) the objectives, RTi,Ti+1 , will depend on the way the meta-learning process is defined. Since we are interested in meta-learning updates that are optimal with respect to the Markovian transitions
between the tasks, we define the expected loss on a pair of consecutive tasks as follows:

RTi,Ti+1 () := Ei1,:K PTi ( |) Ei+1,PTi+1 ( |) LTi+1 (i+1,) | i1,:K , 

(6)

4

Under review as a conference paper at ICLR 2018

The principal difference between the loss in (3) and (6) is that trajectories i1,:K come from the current task, Ti, and are used to construct a policy, , that is good for the upcoming task, Ti+1. Note that even though the policy parameters, i, are sequentially dependent (Fig. 1b), in (6) we always start from the initial parameters,  2. Hence, optimizing RTi,Ti+1 () is equivalent to truncated backpropagation through time with a unit lag in the chain of tasks.
To construct parameters of the policy for task Ti+1, we start from  and do multiple3 meta-gradient steps with adaptive step sizes as follows (assuming the number of steps is M ):

i0 := , 1:K  PTi ( | ),

im := mi -1 - mim-1 LTi

 1:K
i,im-1

,

i+1 := iM-1 - M Mi -1 LTi

 1:K
i,iM -1

m = 1, . . . , M - 1,

(7)

where {m}mM=1 is a set of meta-gradient step sizes that are optimized jointly with . The computation graph for the meta-update is given in Fig. 1c. The expression for the policy gradient is the same as in
(4) but with the expectation is now taken w.r.t. to both Ti and Ti+1:

,RTi,Ti+1 (, ) =
E i1,:K PTi ( |)
i+1,PTi+1 ( |)

LTi+1 (i+1,)

K
, log (i+1,) +  log (ik,)
k=1

(8)

More details and the analog of the policy gradient theorem for our setting are given in Appendix A.
Note that computing meta-updates requires interacting with the environment under  while computing the loss, RTi,Ti+1 , requires using , and hence, interacting with each task in the sequence twice. This is often impossible at execution time, and hence we use slightly different algorithms at training and execution times.
Meta-learning at training time. Once we have access to a distribution over pairs of consecutive tasks4, P(Ti-1, Ti), we can train the meta-updates by optimizing  and  jointly with a gradient method, as given in Algorithm 1. We use  to collect trajectories from Ti and  when interacting with Ti+1. Intuitively, the algorithm is searching for  and  such that the meta-update (7) computed on the trajectories from Ti brings us to a policy  that is good for solving Ti+1. The main assumption here is that the trajectories from Ti contain some information about Ti+1. Note that we treat metaupdates as part of the computation graph (Fig. 1c) and optimize  and  via backpropagation through the entire graph, which requires computing second order derivatives.
Adaptation at execution time. Note that to compute unbiased meta-gradient updates at training time, we have to collect experience in Ti using . At test time, due to environment nonstationarity, we usually do not have the luxury to access to the same task multiple times. Thus, we keep acting according to  and re-use past experience to for computing updates of  for each new incoming task (see Algorithm 2). To adjust for the fact that the past experience was collected under a policy different from , we use importance weight correction. In case of single step meta-update, we have:

i

:=



-

1 
K

K

k=1

( k) i-1 ( k)

L( k),

 1:K  PTi-1 ( | i-1),

(9)

where i-1 and i are used to rollout from Ti-1 and Ti, respectively. Extending importance weight correction to multi-step updates is straightforward and requires simply adding importance weights to
each of the intermediate steps in (7).

2This is due to stability considerations. We find empirically that optimization over sequential updates from
i to i+1 is unstable, often tends to diverge, while starting from the same initialization leads to better behavior. 3Empirically, it turns out that constructing  via multiple meta-gradient steps (between 2 and 5) with adaptive
step sizes tends yield better results in practice. 4Given a sequences of tasks generated by a nonstationary environment, T1, T2, T3, . . . , TL, we use the set of
all pairs of consecutive tasks, {(Ti-1, Ti)}iL=1, as the training distribution.

5

Under review as a conference paper at ICLR 2018

(a) (b) (c)
Fig. 2: (a) The three types of agents used in experiments. The robots differ in the anatomy: the number of legs, their positions, and constraints on the thigh and knee joints. (b) The nonstationary locomotion environment. The torques applied to red-colored legs are scaled by a dynamically changing factor. (c) RoboSumo environment.

4 ENVIRONMENTS

We have designed a set of environments for testing different aspects of continuous adaptation methods in two scenarios: (i) simple environments that change from episode to episode according to some underlying dynamics, and (ii) a competitive multi-agent environment, RoboSumo, that allows different agents to play sequences of games against each other and keep adapting to incremental changes in each other's policies. All our environments are based on MuJoCo physics simulator (Todorov et al., 2012), and all agents are simple multi-leg robots, as shown in Fig. 2a.

4.1 DYNAMIC
First, we consider the problem of robotic locomotion in a changing environment. We use a six-leg agent (Fig. 2b) that observes the absolute position and velocity of its body, the angles and velocities of its legs, and it acts by applying torques to its joints. The agent is rewarded proportionally to its moving speed in a fixed direction. To induce nonstationarity, we select a pair of legs of the agent and scale down the torques applied to the corresponding joints by a factor that linearly changes from 1 to 0 over the course of 7 episodes. In other words, during the first episode all legs are fully functional, while during the last episode the agent has two legs fully paralyzed (even though the policy can generate torques, they are multiplied by 0 before being passed to the environment). The goal of the agent is to learn to adapt from episode to episode by changing its gait so that it is able to move with a maximal speed in a given direction despite the changes in the environment (cf. Cully et al., 2015). Also, there are 15 ways to select a pair of legs of a six-leg creature which gives us 15 different nonstationary environments. This allows us to use a subset of these environments for training and a separate held out set for testing. The training and testing procedures are described in the next section.

4.2 COMPETITIVE

Our multi-agent environment, RoboSumo, allows agents to compete in the 1-vs-1 regime following the standard sumo rules5. We introduce three types of agents, Ant, Bug, and Spider, with different
anatomies (Fig. 2a). During the game, each agent observes positions of itself and the opponent, its
own joint angles, the corresponding velocities, and the forces exerted on its own body (i.e., equivalent
of tactile senses). The action spaces are continuous.

Round 1 Agent:

Round 2

Round 3

Round K

Episodes:

Opponent:
version 1

version 2

version 3

version K

Fig. 3: An agent competes with an opponent in an iterated adaptation games that consist of multi-episode rounds. The agent wins a round if it wins the majority of episodes (wins and losses illustrated with color). Both the agent and its opponent may update their policies from round to round (denoted by the version number).

Iterated adaptation games. To test adaptation, we define the iterated adaptation game (Fig. 3)--a game between a pair of agents that consists of K rounds each of which consists of one or more fixed
5To win, the agent has to push the opponent out of the ring or make the opponent's body touch the ground.

6

Under review as a conference paper at ICLR 2018
length episodes (500 time steps each). The outcome of each round is either win, loss, or draw. The agent that wins the majority of rounds (with at least 5% margin) is declared the winner of the game. There are two distinguishing aspects of our setup: First, the agents are trained either via pure self-play or versus opponents from a fixed training collection. At test time, they face a new opponent from a testing collection. Second, the agents are allowed to learn (or adapt) at test time. In particular, an agent should exploit the fact that it plays against the same opponent multiple consecutive rounds and try to adjust its behavior accordingly. Since the opponent may also be adapting, the setup allows to test different continuous adaptation strategies, one versus the other.
Reward shaping. In RoboSumo, rewards are naturally sparse: the winner gets +2000, the loser is penalized for -2000, and in case of a draw both opponents receive -1000 points. To encourage fast learning at the early stages of training, we shape the rewards given to agents in the following way: the agent (i) gets reward for staying closer to the center of the ring, for moving towards the opponent, and for exerting forces on the opponent's body, and (ii) gets penalty inversely proportional to the opponent's distance to the center of the ring. At test time, the agents continue having access to the shaped reward as well and may use it to update their policies. Throughout our experiments, we use discounted rewards with the discount factor,  = 0.995. More details are in Appendix D.2.
Calibration. To study adaptation, we need a well-calibrated environment in which none of the agents has an initial advantage. To ensure the balance, we increased the mass of the weaker agents (Ant and Spider) such that the win rates in games between one agent type versus the other type in the non-adaptation regime became almost equal (for details on calibration see Appendix D.3).
5 EXPERIMENTS
Our goal is to test different adaptation strategies in the proposed nonstationary RL settings. However, it is known that the test-time behavior of an agent may highly depend on a variety of factors besides the chosen adaptation method, including training curriculum, training algorithm, policy class, etc. Hence, we first describe the precise setup that we use in our experiments to eliminate irrelevant factors and focus on the effects of adaptation. Most of the low-level details are deferred to appendices. Video highlights of our experiments are available at https://goo.gl/tboqaN.
5.1 THE SETUP
Policies. We consider 3 types of policy networks: (i) a 2-layer MLP, (ii) embedding (i.e., 1 fully-connected layer replicated across the time dimension) followed by a 1-layer LSTM, and (iii) RL2 (Duan et al., 2016) of the same architecture as (ii) which additionally takes previous reward and done signals as inputs at each step, keeps the recurrent state throughout the entire interaction with a given environment (or an opponent), and resets the state once the latter changes. For advantage functions, we use networks of the same structure as for the corresponding policies and have no parameter sharing between the two. Our meta-learning agents use the same policy and advantage function structures as the baselines and learn a 3-step meta-update with adaptive step sizes as given in (7). Illustrations and details on the architectures are given in Appendix B.
Meta-learning. We compute meta-updates via gradients of the negative discounted rewards received during a number of previous interactions with the environment. At training time, meta-learners interact with the environment twice, first using the initial policy, , and then the meta-updated policy, . At test time, the agents are limited to interacting with the environment only once, and hence always act according to  and compute meta-updates using importance-weight correction (see Sec. 3.2 and Algorithm 2). Additionally, to reduce the variance of the meta-updates at test time, the agents store the experience collected during the interaction with the test environment (and the corresponding importance weights) into the experience buffer and keep re-using that experience to update  as in (7). The size of the experience buffer is fixed to 3 episodes for nonstationary locomotion and 75 episodes for RoboSumo. More details are given in Appendix C.1.
Adaptation baselines. We consider the following three baseline strategies:
(i) naive (or no adaptation), (ii) implicit adaptation via RL2, and (iii) adaptation via tracking (Sutton et al., 2007) that keeps doing PPO updates at execution time.
7

Under review as a conference paper at ICLR 2018

Total episodic reward

Back two legs 1000

Middle two legs

Front two legs

1000

1000

500 500 500

0 1357

0 1357 Consecutive episodes

0 1357

Policy + adaptation method
MLP MLP + PPO-tracking MLP + meta-updates LSTM LSTM + PPO-tracking LSTM + meta-updates RL2

Fig. 4: Episodic rewards for 7 consecutive episodes in 3 held out nonstationary locomotion environments. To evaluate adaptation strategies, we ran each of them in each environment for 7 episodes followed by a full reset of the environment, policy, and meta-updates (repeated 50 times). Shaded regions are 95% confidence intervals. Best viewed in color.

Training in nonstationary locomotion. We train all methods on the same collection of nonstationary locomotion environments constructed by choosing all possible pairs of legs whose joint torques are scaled except 3 pairs that are held out for testing (i.e., 12 training and 3 testing environments for the six-leg creature). The agents are trained on the environments concurrently, i.e., to compute a policy update, we rollout from all environments in parallel and then compute, aggregate, and average the gradients (for details, see Appendix C.2). LSTM policies retain their state over the course of 7 episodes in each environment. Meta-learning agents compute meta-updates for each nonstationary environment separately.
Training in RoboSumo. To ensure consistency of the training curriculum for all agents, we first pre-train a number of policies of each type for every agent type via pure self-play with the PPO algorithm (Bansal et al., 2017; Schulman et al., 2017). We snapshot and save versions of the pretrained policies at each iteration. This lets us train other agents to play against versions of the pre-trained opponents at various stages of mastery. Next, we train the baselines and the meta-learning agents against the pool of pre-trained opponents6 concurrently. At each iteration k we (a) randomly select an opponent from the training pool, (b) sample a version of the opponent's policy to be in [1, k] (this ensures that even when the opponent is strong, sometimes an undertrained version is selected which allows the agent learn to win at early stages), and (c) rollout against that opponent. All baseline policies are trained with PPO; meta-learners also used PPO as the outer loop for optimizing  and  parameters. We retain the states of the LSTM policies over the course of interaction with the same version of the same opponent and reset it each time the opponent version is updated. Similarly to the locomotion setup, meta-learners compute meta-updates for each opponent in the training pool separately. A more detailed description of the distributed training is given in Appendix C.2.
Experimental design. We design our experiments to answer the following questions:
· When the interaction with the environment before it changes is strictly limited to one or very few episodes, what is the behavior of different adaptation methods in nonstationary locomotion and competitive multi-agent environments?
· What is the sample complexity of different methods, i.e., how many episodes is required for a method to successfully adapt to the changes? We test this by controlling the amount of experience the agent is allowed to get form the same environment before it changes.
Additionally, we ask the following questions specific to the competitive multi-agent setting:
· Given a diverse population of agents that have been trained under the same curriculum, how do different adaptation methods rank in a competition versus each other?
· When the population of agents is evolved for several generations--such that the agents interact with each other via iterated adaptation games, and those that lose disappear while the winners get duplicated--what happens with the proportions of different agents in the population?

6In competitive multi-agent environments, besides self-play, there are plenty of ways to train agents, e.g., train them in pairs against each other concurrently, or randomly match and switch opponents each few iterations. We found that concurrent training often leads to an unbalanced population of agents that have been trained under vastly different curricula and introduces spurious effects that interfere with our analysis of adaptation. Hence, we leave the study of adaptation in naturally emerging curricula in multi-agent settings to the future work.

8

Under review as a conference paper at ICLR 2018

Win rate

Agent: Ant Opponent: Ant
0.6

0.6

0.4 0.4
0.2 0.2
0 25 50 75 100 0.0 0

Agent: 0.8
0.6

Bug Opponent:

Ant

0.8 0.6

0.4 0.4

0.2 0.2 0 25 50 75 100 0

Agent: Spider Opponent: Ant
0.6

0.6

RL2 LSTM + PPO-tracking
Opponent: Bug 0.6

0.4

0.2
25 50 75 100 0 Consecutive rounds
RL2 LSTM + PPO-tracking
Opponent: Bug 0.8 0.6

0.4

25 50 75 Consecutive rounds

0.2 100 0

RL2 LSTM + PPO-tracking
Opponent: Bug 0.6

LSTM + meta-updates
Opponent: Spider
25 50 75 100
LSTM + meta-updates
Opponent: Spider
25 50 75 100
LSTM + meta-updates
Opponent: Spider

Win rate

Win rate

0.4 0.4 0.4

0.2 0.2 0.2
0 25 50 75 100 0 25 50 75 100 0 25 50 75 100 Consecutive rounds
Fig. 5: Win rates for different adaptation strategies in iterated games versus 3 different pre-trained opponents. At test time, both agents and opponents started from versions 700. Opponents' versions were increasing with each consecutive round as if they were learning via self-play, while agents were allowed to adapt only from the limited experience with a given opponent. Each round consisted of 3 episodes. Each iterated game was repeated 100 times; shaded regions denote bootstrapped 95% confidence intervals; no smoothing. Best viewed in color.

5.2 ADAPTATION IN THE FEW-SHOT REGIME AND SAMPLE COMPLEXITY
Few-shot adaptation in nonstationary locomotion environments. Having trained baselines and meta-learning policies as described in Sec. 5.1, we selected 3 testing environments that corresponded to disabling 3 different pairs of legs of the six-leg agent: back, middle, and front legs. The results are presented on Fig. 4. Three observations: First, during the very first episode, the meta-learned initial policy,  , turns out to be suboptimal for the task (it underperforms compared to other policies). However, after 1-2 episodes (and environment changes), it starts performing on par with other policies. Second, by the 6th and 7th episodes, meta-updated policies perform much better than the rest. Note that we use 3 gradient meta-updates for the adaptation of the meta-learners; the meta-updates are computed based on experience collected during the previous 2 episodes. Finally, tracking is not able to improve upon the baseline without adaptation and sometimes leads to even worse results.
Adaptation in RoboSumo under the few-shot constraint. To evaluate different adaptation methods in the competitive multi-agent setting consistently, we consider a variation of the iterated adaptation game, where changes in the opponent's policies at test time are pre-determined but unknown to the agents. In particular, we pre-train 3 opponents (1 of each type, Fig. 2a) with LSTM policies with PPO via self-play (the same way as we pre-train the training pool of opponents, see Sec. 5.1) and snapshot their policies at each iteration. Next, we run iterated games between our trained agents that use different adaptation algorithms versus policy snapshots of the pre-trained opponents. Crucially, the policy version of the opponent keeps increasing from round to round as if it was training via self-play7. The agents have to keep adapting to increasingly more competent versions of the opponent
7At the beginning of the iterated game, both agents and their opponent start from version 700, i.e., from the policy obtained after 700 iterations (PPO epochs) of learning to ensure that the initial policy is reasonable.
9

Under review as a conference paper at ICLR 2018

Win rate

0.6 Ant vs Ant

0.6 Bug vs Bug

0.6 Spider vs Spider

0.5 0.5 0.5

0.4 0.4 0.4

0.3 0.3 0.3

0.20 25 50 75 0.20 25 50 75 0.20 25 50 75 Episodes per round

RL2 LSTM + PPO-tracking LSTM + meta-updates No adaptation

Fig. 6: The effect of increased number of episodes per round in the iterated games versus a learning opponent.

(see Fig. 3). This setup allows us to test different adaptation strategies consistently against the same learning opponents.
The results are given on Fig. 5. We note that meta-learned adaptation strategies, in most cases, are able to adapt and improve their win-rates within about 100 episodes of interaction with constantly improving opponents. On the other hand, performance of the baselines often deteriorates during the rounds of iterated games. Note that the pre-trained opponents were observing 90 episodes of self-play per iteration, while the agents have access to only 3 episodes per round.
Sample complexity of adaptation in RoboSumo. Meta-learning helps to find an update suitable for fast or few-shot adaptation. However, how do different adaptation methods behave when more experience is available? To answer this question, we employ the same setup as previously and vary the number of episodes per round in the iterated game from 3 to 90. Each iterated game is repeated 20 times, and we measure the win-rates during the last 25 rounds of the game.
The results are presented on Fig. 6. When the number of episodes per round goes above 50, adaptation via tracking technically turns into "learning at test time," and it is able to learn to compete against the self-trained opponents that it has never seen at training time. The meta-learned adaptation strategy performed near constantly the same in both few-shot and standard regimes. This suggests that it meta-learned a particular bias at training time that allowed it perform better from limited experience but limited its capacity of utilizing more data. Note that, by design, the meta-updates are fixed to only 3 gradient steps from  with step-sizes  (learned at training), while tracking keeps updating the policy with PPO throughout the iterated game. Allowing for meta-updates that become more flexible with the availability of data can help to overcome this limitation. We leave this to future work.

5.3 EVALUATION ON THE POPULATION-LEVEL
Combining different adaptation strategies with different policies and agents of different morphologies puts us in a situation where we have a diverse population of agents which we would like to rank according to the level of their mastery in adaptation (or find the "fittest"). To do so, we employ TrueSkill (Herbrich et al., 2007)--a metric similar to the ELO rating, but more popular in 1-vs-1 competitive video-games.

40 Sub-population: Ants

40 Sub-population: Bugs

40 Sub-population: Spiders

TrueSkill

30 30 30

20 MLP

20 LSTM
no adaptation

MLP
PPO-tracking

20 LSTM
meta-updates

MLP
RL2

LSTM

Fig. 7: TrueSkill for the top-performing MLP- and LSTM-based agents. TrueSkill was computed based on outcomes (win, loss, or draw) in 1000 iterated adaptation games (100 consecutive rounds per game, 3 episodes per round) between randomly selected pairs of opponents from a population of 105 pre-trained agents.

In this experiment, we consider a population of 105 trained agents: 3 agent types, 7 different policy
and adaptation combinations, and 5 different stages of training (from 500 to 2000 training iterations). First, we assume that the initial distribution of any agent's skill is N (25, 25/3) and the default

10

Under review as a conference paper at ICLR 2018

distance that guarantees about 76% of winning,  = 4.1667. Next, we randomly generate 1000 matches between pairs of opponents and let them adapt while competing with each other in 100-round iterated adaptation games (states of the agents are reset before each game). After each game, we record the outcome and updated our belief about the skill of the corresponding agents using the TrueSkill algorithm8. The distributions of the skill for the agents of each type after 1000 iterated adaptation games between randomly selected players from the pool are visualized in Fig. 7.
There are a few observations we can make: First, recurrent policies were dominant. Second, adaptation via RL2 tended to perform equally or a little worse than plain LSTM with or without tracking in this setup. Finally, agents that meta-learned adaptation rules at training time, consistently demonstrated higher skill scores in each of the categories corresponding to different policies and agent types.

Proportion (%)

100 Spiders
75

50 Bugs

25 Ants
0

0 1 2 3 4 5 6 7 8 9 10
Creature generation (#)

Policy + adaptation
MLP MLP + PPO-tracking MLP + meta-updates LSTM LSTM + PPO-tracking LSTM + meta-updates RL2

Fig. 8: Evolution of a population of 1050 agents for 10 generations. Best viewed in color.

Finally, we enlarge the population from 105 to 1050 agents by duplicating each of them 10 times and evolve it (in the "natural selection" sense) for several generations as follows. Initially, we start with a balanced population of different creatures. Next, we randomly match 1000 pairs of agents, make them play iterated adaptation games, remove the agents that lost from the population and duplicate the winners. The same process is repeated 10 times. The result is presented in Fig 8. We see that many agents quickly disappear form initially uniform population and the meta-learners end up dominating.

6 CONCLUSION AND FUTURE DIRECTIONS
In this work, we proposed a simple gradient-based meta-learning approach suitable for continuous adaptation in nonstationary environments. The key idea of the method is to regard nonstationarity as a sequence of stationary tasks and train agents to exploit the dependencies between consecutive tasks such that they can handle similar nonstationarities at execution time. We applied our method to nonstationary locomotion and within a competitive multi-agent setting. For the latter, we designed the RoboSumo environment and defined iterated adaptation games that allowed us to test various aspects of adaptation strategies. In both cases, meta-learned adaptation rules were more efficient than the baselines in the few-shot regime. Additionally, agents that meta-learned to adapt demonstrated the highest level of skill when competing in iterated games against each other.
The problem of continuous adaptation in nonstationary and competitive environments is far from being solved, and this work is the first attempt to use meta-learning in such setup. Indeed, our meta-learning algorithm has a few limiting assumptions and design choices that we have made mainly due to computational considerations. First, our meta-learning rule is to one-step-ahead update of the policy and is computationally similar to backpropagation through time with a unit time lag. This could potentially be extended to fully recurrent meta-updates that take into account the full history of interaction with the changing environment. Additionally, our meta-updates were based on the gradients of a surrogate loss function. While such updates explicitly optimized the loss, they required computing second order derivatives at training time, slowing down the training process by an order of magnitude compared to baselines. Utilizing information provided by the loss but avoiding explicit backpropagation through the gradients would be more appealing and scalable. Finally, our approach is unlikely to work with sparse rewards as the meta-updates use policy gradients and heavily rely on the reward signal. Introducing auxiliary dense rewards designed to enable meta-learning is a potential way to overcome this issue that we would like to explore in the future work.
8We used an implementation from http://trueskill.org/.

11

Under review as a conference paper at ICLR 2018
REFERENCES
Marcin Andrychowicz, Misha Denil, Sergio Gomez, Matthew W Hoffman, David Pfau, Tom Schaul, and Nando de Freitas. Learning to learn by gradient descent by gradient descent. In Advances in Neural Information Processing Systems, pp. 3981­3989, 2016.
Trapit Bansal, Jakub Pachocki, Szymon Sidor, Ilya Sutskever, and Igor Mordatch. Emergent complexity via multi-agent competition. arXiv preprint arXiv:1710.03748, 2017.
Samy Bengio, Yoshua Bengio, Jocelyn Cloutier, and Jan Gecsei. On the optimization of a synaptic learning rule. In Preprints Conf. Optimality in Artificial and Biological Neural Networks, pp. 6­8. Univ. of Texas, 1992.
Yoshua Bengio, Samy Bengio, and Jocelyn Cloutier. Learning a synaptic learning rule. Université de Montréal, Département d'informatique et de recherche opérationnelle, 1990.
Michael Bowling. Convergence and no-regret in multiagent learning. In Advances in neural information processing systems, pp. 209­216, 2005.
Yongcan Cao, Wenwu Yu, Wei Ren, and Guanrong Chen. An overview of recent progress in the study of distributed multi-agent coordination. IEEE Transactions on Industrial informatics, 9(1): 427­438, 2013.
Rich Caruana. Multitask learning. In Learning to learn, pp. 95­133. Springer, 1998.
Vincent Conitzer and Tuomas Sandholm. Awesome: A general multiagent learning algorithm that converges in self-play and learns a best response against stationary opponents. Machine Learning, 67(1-2):23­43, 2007.
Antoine Cully, Jeff Clune, Danesh Tarapore, and Jean-Baptiste Mouret. Robots that can adapt like animals. Nature, 521(7553):503­507, 2015.
Bruno C Da Silva, Eduardo W Basso, Ana LC Bazzan, and Paulo M Engel. Dealing with nonstationary environments using context detection. In Proceedings of the 23rd international conference on Machine learning, pp. 217­224. ACM, 2006.
Yan Duan, John Schulman, Xi Chen, Peter L Bartlett, Ilya Sutskever, and Pieter Abbeel. Rl2: Fast reinforcement learning via slow reinforcement learning. arXiv preprint arXiv:1611.02779, 2016.
Harrison Edwards and Amos Storkey. Towards a neural statistician. arXiv preprint arXiv:1606.02185, 2016.
Chelsea Finn, Pieter Abbeel, and Sergey Levine. Lifelong few-shot learning. In Lifelong Learning: A Reinforcement Learning Approach ICML workshop, 2017a.
Chelsea Finn, Pieter Abbeel, and Sergey Levine. Model-agnostic meta-learning for fast adaptation of deep networks. arXiv preprint arXiv:1703.03400, 2017b.
Jakob Foerster, Gregory Farquhar, Triantafyllos Afouras, Nantas Nardelli, and Shimon Whiteson. Counterfactual multi-agent policy gradients. arXiv preprint arXiv:1705.08926, 2017a.
Jakob N Foerster, Richard Y Chen, Maruan Al-Shedivat, Shimon Whiteson, Pieter Abbeel, and Igor Mordatch. Learning with opponent-learning awareness. arXiv preprint arXiv:1709.04326, 2017b.
David Ha, Andrew Dai, and Quoc V Le. Hypernetworks. arXiv preprint arXiv:1609.09106, 2016.
Ralf Herbrich, Tom Minka, and Thore Graepel. TrueskillTM: a bayesian skill rating system. In Advances in neural information processing systems, pp. 569­576, 2007.
Sepp Hochreiter, A Steven Younger, and Peter R Conwell. Learning to learn using gradient descent. In International Conference on Artificial Neural Networks, pp. 87­94. Springer, 2001.
Sergey Levine, Chelsea Finn, Trevor Darrell, and Pieter Abbeel. End-to-end training of deep visuomotor policies. Journal of Machine Learning Research, 17(39):1­40, 2016.
12

Under review as a conference paper at ICLR 2018
Jiwei Li, Will Monroe, Alan Ritter, Michel Galley, Jianfeng Gao, and Dan Jurafsky. Deep reinforcement learning for dialogue generation. arXiv preprint arXiv:1606.01541, 2016.
Ke Li and Jitendra Malik. Learning to optimize. arXiv preprint arXiv:1606.01885, 2016.
Ryan Lowe, Yi Wu, Aviv Tamar, Jean Harb, Pieter Abbeel, and Igor Mordatch. Multi-agent actorcritic for mixed cooperative-competitive environments. arXiv preprint arXiv:1706.02275, 2017.
Michael McCloskey and Neal J Cohen. Catastrophic interference in connectionist networks: The sequential learning problem. Psychology of learning and motivation, 24:109­165, 1989.
Richard Mealing and Jonathan L Shapiro. Opponent modelling by sequence prediction and lookahead in two-player games. In International Conference on Artificial Intelligence and Soft Computing, pp. 385­396. Springer, 2013.
Tom M Mitchell, William W Cohen, Estevam R Hruschka Jr, Partha Pratim Talukdar, Justin Betteridge, Andrew Carlson, Bhavana Dalvi Mishra, Matthew Gardner, Bryan Kisiel, Jayant Krishnamurthy, et al. Never ending learning. In AAAI, pp. 2302­2310, 2015.
Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Andrei A Rusu, Joel Veness, Marc G Bellemare, Alex Graves, Martin Riedmiller, Andreas K Fidjeland, Georg Ostrovski, et al. Human-level control through deep reinforcement learning. Nature, 518(7540):529­533, 2015.
Peng Peng, Quan Yuan, Ying Wen, Yaodong Yang, Zhenkun Tang, Haitao Long, and Jun Wang. Multiagent bidirectionally-coordinated nets for learning to play starcraft combat games. arXiv preprint arXiv:1703.10069, 2017.
Sachin Ravi and Hugo Larochelle. Optimization as a model for few-shot learning. 2016.
Adam Santoro, Sergey Bartunov, Matthew Botvinick, Daan Wierstra, and Timothy Lillicrap. Metalearning with memory-augmented neural networks. In International conference on machine learning, pp. 1842­1850, 2016.
Jurgen Schmidhuber. Evolutionary principles in self-referential learning. On learning how to learn: The meta-meta-... hook.) Diploma thesis, Institut f. Informatik, Tech. Univ. Munich, 1987.
Jürgen Schmidhuber. Learning to control fast-weight memories: An alternative to dynamic recurrent networks. Learning, 4(1), 1992.
John Schulman, Sergey Levine, Pieter Abbeel, Michael Jordan, and Philipp Moritz. Trust region policy optimization. In Proceedings of the 32nd International Conference on Machine Learning (ICML-15), pp. 1889­1897, 2015a.
John Schulman, Philipp Moritz, Sergey Levine, Michael Jordan, and Pieter Abbeel. High-dimensional continuous control using generalized advantage estimation. arXiv preprint arXiv:1506.02438, 2015b.
John Schulman, Filip Wolski, Prafulla Dhariwal, Alec Radford, and Oleg Klimov. Proximal policy optimization algorithms. arXiv preprint arXiv:1707.06347, 2017.
Daniel L Silver, Qiang Yang, and Lianghao Li. Lifelong machine learning systems: Beyond learning algorithms. In AAAI Spring Symposium: Lifelong Machine Learning, volume 13, pp. 05, 2013.
David Silver, Aja Huang, Chris J Maddison, Arthur Guez, Laurent Sifre, George Van Den Driessche, Julian Schrittwieser, Ioannis Antonoglou, Veda Panneershelvam, Marc Lanctot, et al. Mastering the game of go with deep neural networks and tree search. Nature, 529(7587):484­489, 2016.
Satinder Singh, Michael Kearns, and Yishay Mansour. Nash convergence of gradient dynamics in general-sum games. In Proceedings of the Sixteenth conference on Uncertainty in artificial intelligence, pp. 541­548. Morgan Kaufmann Publishers Inc., 2000.
Jake Snell, Kevin Swersky, and Richard S Zemel. Prototypical networks for few-shot learning. arXiv preprint arXiv:1703.05175, 2017.
13

Under review as a conference paper at ICLR 2018
Richard S Sutton, David A McAllester, Satinder P Singh, and Yishay Mansour. Policy gradient methods for reinforcement learning with function approximation. In Advances in neural information processing systems, pp. 1057­1063, 2000.
Richard S Sutton, Anna Koop, and David Silver. On the role of tracking in stationary environments. In Proceedings of the 24th international conference on Machine learning, pp. 871­878. ACM, 2007.
Sebastian Thrun. Lifelong learning algorithms. Learning to learn, 8:181­209, 1998. Sebastian Thrun and Lorien Pratt. Learning to learn. Springer, 1998. Emanuel Todorov, Tom Erez, and Yuval Tassa. Mujoco: A physics engine for model-based control.
In Intelligent Robots and Systems (IROS), 2012 IEEE/RSJ International Conference on, pp. 5026­ 5033. IEEE, 2012. Oriol Vinyals, Charles Blundell, Tim Lillicrap, Daan Wierstra, et al. Matching networks for one shot learning. In Advances in Neural Information Processing Systems, pp. 3630­3638, 2016. Jane X Wang, Zeb Kurth-Nelson, Dhruva Tirumala, Hubert Soyer, Joel Z Leibo, Remi Munos, Charles Blundell, Dharshan Kumaran, and Matt Botvinick. Learning to reinforcement learn. arXiv preprint arXiv:1611.05763, 2016. Ronald J Williams. Simple statistical gradient-following algorithms for connectionist reinforcement learning. Machine learning, 8(3-4):229­256, 1992. Chongjie Zhang and Victor R Lesser. Multi-agent learning with policy prediction. In AAAI, 2010.
14

Under review as a conference paper at ICLR 2018

A DERIVATIONS AND THE POLICY GRADIENT THEOREM

In this section, we derive the policy gradient update for MAML as give in (4) as well as formulate and equivalent of the policy gradient theorem (Sutton et al., 2000) in the learning-to-learn setting.

Our derivation is not bound to a particular form of the meta-update. In general, we are interested in meta-learning a procedure, f, parametrized by , which, given access to a limited experience on a task, can produce a good policy for solving it. Note that f is responsible for both collecting the initial experience and constructing the final policy for the given task. For example, in case of MAML (Finn et al., 2017b), f is represented by the initial policy, , and the meta-update rule (4) that produces  with  :=  - L(1:K ).
More formally, after querying K trajectories, 1:K , we want to produce  that minimizes the expected loss w.r.t. the distribution over tasks:

R() := ET D(T ) E1:K pT ( |) EpT ( |) LT () | 1:K

(10)

Note that the inner-most expectation is conditional on the experience, 1:K , which our meta-learning procedure, f, collects to produce a task-specific policy, . Assuming that the loss L(1:K ) is linear in trajectories, and using linearity of expectations, we can drop the superscript 1 : K and denote the
trajectory sampled under  for task Ti simply as ,i. At training time, we are given a finite sample of tasks from the distribution D(T ) and can search for ^ close to optimal by optimizing over the
empirical distribution:

^ := argmin R^(),


where R^() :=

1 N

N
E,ipTi ( |)
i=1

E,ipTi ( |) [LTi (,i) | ,i]

(11)

We re-write the objective function for task Ti in (11) more explicitly by expanding the expectations:

RTi () := E,ipTi ( |) E,ipTi ( |) [LTi (,i) | ,i] = LTi (,i) PTi (,i | ) PTi ( | , ,i) PTi (,i | ) d,i d d,i

(12)

Trajectories, ,i and ,i, and parameters  of the policy  can be thought as random variables that we marginalize out to construct the objective that depends on  only. The meta-update rule (4) assumes the following PTi ( | , ,i):

PTi ( | , ,i) := 



-



1 K

K

L(k,i)

k=1

(13)

Note that by specifying PTi ( | , ,i) differently, we may arrive at different meta-learning algorithms. After plugging (13) into (12) and integrating out , we get the following expected loss for
task Ti as a function of :

RTi () = E,ipTi ( |) E,ipTi ( |) [LTi (,i) | ,i] =

LTi (,i) PTi

,i

|



-



1 K

K

L(k,i)

k=1

PTi (,i | ) d,i d,i

The gradient of (14) will take the following form:

(14)

RTi () =

[LTi (,i)  log PTi (,i | )] PTi (,i | ) PTi (,i | ) d d,i+ [LTi ( )  log PTi (,i | )] PTi ( | ) PTi (,i | ) d d,i

(15)

where  = (, 1,:iK ) as given in (14). Note that the expression consists of two terms: the first term is the standard policy gradient w.r.t. the meta-updated policy, , while the second one is the policy gradient w.r.t. the original policy, , that is used to collect 1,:iK . If we were to omit marginalization

15

Under review as a conference paper at ICLR 2018

of 1,:iK (as it was done in the original paper (Finn et al., 2017b)), the terms would disappear. Finally, the gradient can be re-written in a more succinct form:

K

RTi () = E1,:iK PTi ( |) LTi ( )  log ( ) + 

log (k)

(16)

 PTi ( |)

k=1

The update given in (16) is an unbiased estimate of the gradient as long as the loss LTi is simply the

sum of discounted rewards (i.e., it extends the classical REINFORCE algorithm (Williams, 1992) to

meta-learning). Similarly, we can define LTi that uses a value or advantage function and extend the policy gradient theorem Sutton et al. (2000) to make it suitable for meta-learning.

Theorem 1 (Meta policy gradient theorem). For any MDP, gradient of the value function w.r.t.  takes the following form:

VT(x0) =

E1:K pT ( |)

dT (x)

(a 

|

x)

QT

(a,

x)

+

xa

E1:K pT ( |)

 

K

log (k)

k=1

(a | x0)QT (a, x0)
a

where dT (x) is the stationary distribution under policy .

,

(17)

Proof. We define task-specific value functions under the generated policy, , as follows:

H

VT(x0) = E pT ( |)

tRT (xt) | x0 ,

QT (x0, a0) = E pT ( |)

t=k
H
tRT (xt) | x0, a0
t=k

,

(18)

where the expectations are taken w.r.t. the dynamics of the environment of the given task, T , and the

policy, . Next, we need to marginalize out 1:K :

H

VT(x0) = E1:K pT ( |) E pT ( |)

tRT (xt) | x0

,

(19)

t=k

and after the gradient w.r.t. , we arrive at:

VT(x0) =

E1:K pT ( |)

(a | 

x0)

QT

(a,

x0)

+

(a

|

x0)

QT (a, 

x0)

+

a

(20)

E1:K pT ( |)

K  log (k)
k=1

(a | x0)QT (a, x0) ,
a

where the first term is similar to the expression used in the original policy gradient theorem (Sutton

et al., 2000) while the second one comes from differentiating trajectories 1:K that depend on . Following Sutton et al. (2000), we unroll the derivative of the Q-function in the first term and arrive

at the following final expression for the policy gradient:

VT(x0) =

E1:K pT ( |) E1:K pT ( |)

dT (x)

(a 

|

x)

QT

(a,

x)

+

xa

 

K

log (k)

k=1

(a | x0)QT (a, x0)
a

(21)

Remark 1. The same theorem is applicable to the continuous setting with the only changes in the
distributions used to compute expectations in (17) and (18). In particular, the outer expectation in (17) should be taken w.r.t. pTi ( | ) while the inner expectation w.r.t. pTi+1 ( | ).

16

Under review as a conference paper at ICLR 2018

A.1 MULTIPLE META-GRADIENT STEPS

All our derivations so far assumed single step gradient-based meta-update. Experimentally, we found that the multi-step version of the update often leads to a more stable training and better test time performance. In particular, we construct  via intermediate M gradient steps:

m

:=

m-1

-

m m-1

1 K

K

L(km-1),

k=1

1m:K-1  pT ( | m-1),

m = 1, . . . , M - 1,



:=

M -1

-

M -1M-1

1 K

K

L(kM -1 ),

k=1

1M:K-1  pT ( | M-1),

(22)

where m are intermediate policy parameters. Note that each intermediate step, m, requires interacting with the environment and sampling intermediate trajectories, 1m:K . To compute the policy gradient, we need to marginalize out all the intermediate random variables, m and 1m:K , m = 1, . . . , M . The objective function (12) takes the following form:

RT () =

LT ( ) PT ( | ) PT  | M-1, 1M:K-1 d d×

M -2
PT 1m:K+1 | m+1 PT (m+1 | m, 1m:K ) d1m:K+1dm+1×
m=1
PT (1:K | ) d1:K

(23)

Since PT (m+1 | m, 1m:K ) at each intermediate steps are delta functions, the final expression for the multi-step MAML objective has the same form as (14), with integration taken w.r.t. all intermediate
trajectories. Similarly, an unbiased estimate of the gradient of the objective gets M additional terms:

 R = E T

{1m:K }mM=-01,

LT ( )

M -1

K

 log ( ) +

 log m (km)

m=0 k=1

,

(24)

where the expectation is taken w.r.t. trajectories (including all intermediate ones). Again, note that at training time we do not constrain the number of interactions with each particular environment and do rollout using each intermediate policy to compute updates. At testing time, we interact with the environment only once and rely on the importance weight correction as described in Sec. 3.2.

17

Under review as a conference paper at ICLR 2018

surrogate loss

at Vt

MLP
64 x 64

MLP
64 x 64

surrogate loss

at Vt

LSTM
64 x 64

LSTM
64 x 64

surrogate loss

at Vt

LSTM
64 x 64

LSTM
64 x 64

xt (a) MLP

xt (b) LSTM

xt dt-1 rt-1 (c) RL2

Fig. 9: Policy and value function architectures.

B ADDITIONAL DETAILS ON THE ARCHITECTURES
The neural architectures used for our policies and value functions are illustrated in Fig. 9. Our MLP architectures were memory-less and reactive. The LSTM architectures had used a fully connected embedding layer (with 64 hidden units) followed by a recurrent layer (also with 64 units). The state in LSTM-based architectures was kept throughout each episode and reset to zeros at the beginning of each new episode. The RL2 architecture additionally took reward and done signals from the previous time step and kept the state throughout the whole interactions with a given environment (or opponent). The recurrent architectures were unrolled for T = 10 time steps and optimized with PPO via backprop through time.
C ADDITIONAL DETAILS ON META-LEARNING AND OPTIMIZATION
C.1 META-UPDATES FOR CONTINUOUS ADAPTATION
Our meta-learned adaptation methods were used with MLP and LSTM policies (Fig. 9). The metaupdates were based on 3 gradient steps with adaptive step sizes  were initialized with 0.001. There are a few additional details to note:
1.  and  parameters were a concatenation of the policy and the value function parameters. 2. At the initial stages of optimization, meta-gradient steps often tended to "explode", hence
we clipped them by values norms to be between -0.1 and 0.1. 3. We used different surrogate loss functions for the meta-updates and for the outer optimization.
For meta-updates, we used the vanilla policy gradients computed on the negative discounted rewards, while for the outer optimization loop we used the PPO objective.
C.2 ON PPO AND ITS DISTRIBUTED IMPLEMENTATION
As mentioned in the main text and similar to (?), large batch sizes were used to ensure enough exploration throughout policy optimization and were critical for learning in the competitive setting of RoboSumo. In our experiments, the epoch size of the PPO was set 32,000 episodes and the batch size was set to 8,000. The PPO clipping hyperparameter was set to = 0.2 and the KL penalty was set to 0. In all our experiments, the learning rate (for meta-learning, the learning rate for  and ) was set to 0.0003. The generalized advantage function estimator (GAE) (Schulman et al., 2015b) was optimized jointly with the policy (we used  = 0.995 and  = 0.95).
To train our agents in reasonable time, we used a distributed implementation of the PPO algorithm. To do so, we versioned the agent's parameters (i.e., kept parameters after each update and assigned it a version number) and used a versioned queue for rollouts. Multiple worker machines were generating rollouts in parallel for the most recent available version of the agent parameters and were pushing them into the versioned rollout queue. The optimizer machine collected rollouts from the queue and made a PPO optimization steps (see (Schulman et al., 2017) for details) as soon as enough rollouts were available.
18

Under review as a conference paper at ICLR 2018

We trained agents on multiple environments simultaneously. In nonstationary locomotion, each environment corresponded to a different pair of legs of the creature becoming dysfunctional. In RoboSumo, each environment corresponded to a different opponent in the training pool. Simultaneous training was achieved via assigning these environments to rollout workers uniformly at random, so that the rollouts in each mini-batch were guaranteed to come from all training environments.

D ADDITIONAL DETAILS ON THE ENVIRONMENTS

D.1 OBSERVATION AND ACTION SPACES

Both observation and action spaces in RoboSumo continuous. The observations of each agent consist of the position of its own body (7 dimensions that include 3 absolute coordinates in the global cartesian frame and 4 quaternions), position of the opponent's body (7 dimensions), its own joint angles and velocities (2 angles and 2 velocities per leg), and forces exerted on each part of its own body (6 dimensions for torso and 18 for each leg) and forces exerted on the opponent's torso (6 dimensions). All forces were squared and clipped at 100. Additionally, we normalized observations using a running mean and clipped their values between -5 and 5. The action spaces had 2 dimensions per joint. Table 1 summarizes the observation and action spaces for each agent type.
Table 1: Dimensionality of the observation and action spaces of the agents in RoboSumo.

Agent
Ant Bug Spider

Coordinates
15
19 23

Observation space Self Opponent Velocities Forces Coordinates Forces

14 78

7

6

18 114 22 150

7 7

6 6

Action space
8 12 16

Note that the agents observe neither any of the opponents velocities, nor positions of the opponent's limbs. This allows us to keep the observation spaces consistent regardless of the type of the opponent. However, even though the agents are blind to the opponent's limbs, they can sense them via the forces applied to the agents' bodies when in contact with the opponent.
D.2 SHAPED REWARDS
In RoboSumo, the winner gets 2000 reward, the loser is penalized for -2000, and in case of draw both agents get -1000. In addition to the sparse win/lose rewards, we used the following dense rewards to encourage fast learning at the early training stages:
· Quickly push the opponent outside. The agent got penalty at each time step proportional to exp{-dopp} where dopp was the distance of the opponent from the center of the ring.
· Moving towards the opponent. Reward at each time step proportional to magnitude of the velocity component towards the opponent.
· Hit the opponent. Reward proportional to the square of the total forces exerted on the opponent's torso.
· Control penalty. The l2 penalty on the actions to prevent jittery/unnatural movements.
D.3 RO B OSU M O CALIBRATION
To calibrate the RoboSumo environment we used the following procedure. First, we trained each agent via pure self-play with LSTM policy using PPO for the same number of iterations, tested them one against the other (without adaptation), and recorded the win rates (Table 2). To ensure the balance, we kept increasing the mass of the weaker agents and repeated the calibration procedure until the win rates equilibrated.
19

Under review as a conference paper at ICLR 2018

Table 2: Win rates for the first agent in the 1-vs-1 RoboSumo without adaptation before and after calibration.

Masses (Ant, Bug, Spider)
Initial (10, 10, 10) Calibrated (13, 10, 39)

Ant vs. Bug
25.2 ± 3.9% 50.6 ± 5.6%

Ant vs. Spider
83.6 ± 3.1% 51.6 ± 3.4%

Bug vs. Spider
90.2 ± 2.7% 51.7 ± 2.8%

E ADDITIONAL DETAILS ON EXPERIMENTS

E.1 AVERAGE WIN RATES
Table 3 gives average win rates for the last 25 rounds of iterated adaptation games played by different agents with different adaptation methods (win rates for each episode are visualized in Figure 5).

Table 3: Average win-rates (95% CI) in the last 25 rounds of the 100-round iterated adaptation games between different agents and different opponents. The base policy and value function were LSTMs with 64 hidden units.

Agent Ant Bug Spider

Opponent
Ant Bug Spider
Ant Bug Spider
Ant Bug Spider

RL2
24.9 (5.4)% 21.0 (6.3)% 24.8 (10.5)%
33.5 (6.9)% 28.6 (7.4)% 45.8 (8.1)%
40.3 (9.7)% 38.4 (7.2)% 33.9 (7.2)%

Adaptation Strategy LSTM + PPO-tracking LSTM + meta-updates

30.0 (6.7)% 15.6 (7.1)% 27.6 (8.4)%

44.0 (7.7)% 34.6 (8.1)% 35.1 (7.7)%

26.6 (7.4)% 21.2 (4.2)% 42.6 (12.9)%

39.5 (7.1)% 43.7 (8.0)% 52.0 (13.9)%

48.0 (9.8)% 43.9 (7.1)% 42.2 (3.9)%

45.3 (10.9)% 48.4 (9.2)% 46.7 (3.8)%

E.2 TRUESKILL RANK OF THE TOP AGENTS

Rank Agent

TrueSkill rank*

Bug+LSTM-meta - 1 0.50 0.59 0.69 0.70 0.70 0.89 0.93 0.94 0.97 0.97

1 Bug + LSTM-meta 2 Ant + LSTM-meta 3 Bug + LSTM-track 4 Ant + RL2 5 Ant + LSTM

31.7 30.8 29.1 28.6 28.4

6 Bug + MLP-meta 7 Ant + MLP-meta

23.4 21.6

8 Spider + MLP-meta

20.5

9 Spider + MLP

19.0

10 Bug + MLP-track

18.9

* The rank is a conservative estimate of the skill, r = µ - 3, to ensure that the actual skill of the agent is higher with 99% confidence.

Ant+LSTM-meta - 2 0.41 0.50 0.60 0.62 0.62 0.85 0.90 0.92 0.96 0.95 Bug+LSTM-track - 3 0.31 0.40 0.50 0.51 0.51 0.78 0.84 0.88 0.93 0.92
Ant+LSTM-RL2 - 4 0.30 0.38 0.49 0.50 0.50 0.77 0.83 0.87 0.92 0.91 Ant+LSTM - 5 0.30 0.38 0.49 0.50 0.50 0.77 0.83 0.87 0.92 0.91
Bug+MLP-meta - 6 0.11 0.15 0.22 0.23 0.23 0.50 0.60 0.65 0.75 0.74 Ant+MLP-meta - 7 0.07 0.10 0.16 0.17 0.17 0.40 0.50 0.56 0.66 0.65 Spd+MLP-meta - 8 0.06 0.08 0.12 0.13 0.13 0.35 0.44 0.50 0.61 0.60
Spd+MLP - 9 0.03 0.04 0.07 0.08 0.08 0.25 0.34 0.39 0.50 0.49 Bug+MLP-track - 10 0.03 0.05 0.08 0.09 0.09 0.26 0.35 0.40 0.51 0.50
1 2 3 4 5 6 7 8 9 10

Table 4 & Fig. 10: Top-5 agents with MLP and LSTM policies from the population ranked by TrueSkill. The heatmap shows a priori win-rates in iterated games based on TrueSkill for the top agents against each other.

Since TrueSkill represents the belief about the skill of an agent as a normal distribution (i.e., with two parameters, µ and ), we can use it to infer a priori probability of an agent, a, winning against

20

Under review as a conference paper at ICLR 2018

its opponent, o, as follows (Herbrich et al., 2007):

P (a wins o) = 

µa - µo 22 + a2 + o2

,

where

(x)

:=

1 2

1 + erf

x 2

(25)

The ranking of the top-5 agents with MLP and LSTM policies according to their TrueSkill is given in Tab. 1 and the a priori win rates in Fig. 10. Note that within the LSTM and MLP categories, the best meta-learners are 10 to 25% more likely to win the best agents that use other adaptation strategies.

E.3 INTOLERANCE TO LARGE DISTRIBUTIONAL SHIFTS
Continuous adaptation via meta-learning assumes consistency in the changes of the environment or the opponent. What happens if the changes are drastic? Unfortunately, the training process of our meta-learning procedure turns out to be sensitive to such shifts and can diverge when the distributional shifts from iteration to iteration are large. Fig. 11 shows the training curves for a meta-learning agent with MLP policy trained against versions of an MLP opponent pre-trained via self-play. At each iteration, we kept updating the opponent policy by 1 to 10 steps. The meta-learned policy was able to achieve non-negative rewards by the end of training only when the opponent was changing up to 4 steps per iteration.

# of opponent updates per iteration

1 step

4 steps

7 steps

10 steps

Avg. reward per episode

2000 1000
0 -1000 -2000 -3000
0

500 1000 1500 Iteration

Fig. 11: Reward curves for a meta-learning agent trained against a learning opponent. Both agents were Ants with MLP policies. At each iteration, the opponent was updating its policy for a given number of steps using self-play, while the meta-learning agent attempted to learn to adapt to the distributional shifts. For each setting, the training process was repeated 15 times; shaded regions denote 90% confidence intervals.

21

