Under review as a conference paper at ICLR 2018
SKIP RNN: LEARNING TO SKIP STATE UPDATES IN RECURRENT NEURAL NETWORKS
Anonymous authors Paper under double-blind review
ABSTRACT
Recurrent Neural Networks (RNNs) continue to show outstanding performance in sequence modeling tasks. However, training RNNs on long sequences often face challenges like slow inference, vanishing gradients and difficulty in capturing long term dependencies. In backpropagation through time settings, these issues are tightly coupled with the large, sequential computational graph resulting from unfolding the RNN in time. We introduce the Skip RNN model which extends existing RNN models by learning to skip state updates and shortens the effective size of the computational graph. This model can also be encouraged to perform fewer state updates through a budget constraint. We evaluate the proposed model on various tasks and show how it can reduce the number of required RNN updates while preserving, and sometimes even improving, the performance of the baseline RNN models. Source code will be made publicly available upon publication of this work.
1 INTRODUCTION
Recurrent Neural Networks (RNNs) have become the standard approach for practitioners when addressing machine learning tasks involving sequential data. Such success has been enabled by the appearance of larger datasets, more powerful computing resources and improved architectures and training algorithms. Gated units, such as the Long Short-Term Memory (Hochreiter & Schmidhuber, 1997) (LSTM) and the Gated Recurrent Unit (Cho et al., 2014) (GRU), were designed to deal with the vanishing gradients problem commonly found in RNNs (Bengio et al., 1994). These architectures have become popularized thanks to their impressive results in a variety of tasks such as machine translation (Bahdanau et al., 2015), language modeling (Zaremba et al., 2015) or speech recognition (Graves et al., 2013).
Some of the main limitations of RNNs are their challenging training and deployment when dealing with long sequences, due to their inherently sequential behaviour. These challenges include throughput degradation, slower convergence during training and memory leakage, even for gated architectures (Neil et al., 2016). Sequence shortening techniques, which can be seen as a sort of conditional computation (Bengio et al., 2013; Bengio, 2013; Davis & Arel, 2013) in time, can alleviate these issues. The most common approaches, such as cropping discrete signals or reducing the sampling rate in continuous signals, are based on heuristics and can be suboptimal. In contrast, we propose a model that is able to learn which samples (i.e. elements in the input sequence) need to be used in order to solve the target task. Consider a video understanding task as an example: scenes with large motion may benefit from high frame rates, whereas only a few frames are needed to capture the semantics of a mostly static scene.
The main contribution of this work is a novel modification for existing RNN architectures that allows them to skip state updates, decreasing the number of sequential operations to be performed, without requiring any additional supervision signal. This model, called Skip RNN, adaptively determines whether the state needs to be updated or copied to the next time step. We show how the network can be encouraged to perform fewer state updates by adding a penalization term during training, allowing us to train models under different computation budgets. The proposed modification is implemented on top of well-known RNN architectures, namely LSTM and GRU, and the resulting models show promising results in a series of sequence modeling tasks. In particular, the proposed Skip RNN architecture is evaluated on six sequence learning problems: an adding task,
1

Under review as a conference paper at ICLR 2018
sine wave frequency discrimination, digit classification, sentiment analysis in movie reviews, action classification in video and temporal action localization in video1.
2 RELATED WORK
Conditional computation has been shown to allow gradual increases in model capacity without a proportional increases in computational cost by exploiting certain computation paths for each input (Bengio et al., 2013; Liu & Deng, 2017; Almahairi et al., 2016; McGill & Perona, 2017; Shazeer et al., 2017). This idea has been extended in the temporal domain, either by learning how many times an input needs to be pondered before moving to the next one (Graves, 2016) or building RNNs whose number of layers depends on the input data (Chung et al., 2017). Some works have addressed time-dependent computation in RNNs by updating only a fraction of the hidden states based on the current hidden state and input (Jernite et al., 2017), or following periodic patterns (Koutnik et al., 2014; Neil et al., 2016). However, due to the inherently sequential nature of RNNs and the parallel computation capabilities of modern hardware, reducing the size of the matrices involved in the computations performed at each time step does not accelerate inference. The proposed Skip RNN model can be seen as form of conditional computation in time, where the computation associated to the RNN updates may or may not be executed at every time step. This is related to the UPDATE and COPY operations in hierarchical multiscale RNNs (Chung et al., 2017), but applied to the whole stack of RNN layers at the same time. This difference is key to allowing our approach to skip input samples, effectively reducing sequential computation and shielding the hidden state over longer time lags. Learning whether to update or copy the hidden state through time steps can be seen as a learnable Zoneout mask (Krueger et al., 2017) which is shared between all the units in the hidden state. Similarly, it can be interpreted as an input-dependent recurrent version of stochastic depth (Huang et al., 2016).
Selecting parts of the input signal is similar in spirit to the hard attention mechanisms that have been applied to image regions (Mnih et al., 2014), where only some patches of the input image are attended in order to generate captions (Xu et al., 2015) or detect objects (Ba et al., 2014). Our model can be understood to generate a hard temporal attention mask on the fly given the previously seen samples, deciding which time steps should be attended and operating on a subset of input samples. Subsampling input sequences has been explored for visual storylines generation (Sigurdsson et al., 2016b), although jointly optimizing the RNN weights and the subsampling mechanism is computationally unfeasible and the Expectation Maximization algorithm is used instead. Similar research has been conducted for video analysis tasks, discovering minimally needed evidence for event recognition (Bhattacharya et al., 2014) and training agents that decide which frames need to be observed in order to localize actions in time (Yeung et al., 2016; Su & Grauman, 2016). Motivated by the advantages of training recurrent models on shorter subsequences, efforts have been conducted towards learning differentiable subsampling mechanisms (Raffel & Lawson, 2017), although the computational complexity of the proposed method precludes its application to long input sequences. In contrast, our proposed method can be trained with backpropagation and does not degrade the complexity of the baseline RNNs.
Accelerating inference in RNNs is difficult due to their inherently sequential nature, leading to the design of Quasi-Recurrent Neural Networks (Bradbury et al., 2017) and Simple Recurrent Units (Lei & Zhang, 2017), which relax the temporal dependency between consecutive steps. With the goal of speeding up RNN inference, LSTM-Jump (Yu et al., 2017) augments an LSTM cell with a classification layer that will decide how many steps to jump between RNN updates. Despite its promising results on text tasks, the model needs to be trained with REINFORCE (Williams, 1992), which requires the definition of a reward signal. Determining such reward signal is not trivial and does not necessarily generalize across tasks, e.g. regression and classification tasks may require from different reward signals. Moreover, the number of tokens read between jumps, the maximum jump distance and the number of jumps allowed need to be chosen ahead of time. These hyperparameters define a reduced set of subsequences that the model can sample, instead of allowing the network to learn any arbitrary sampling scheme. Unlike LSTM-Jump, our proposed approach is differentiable,
1Experiments on sine wave frequency discrimination, sentiment analysis in movie reviews and action classification in video are reported in the appendix due to space limitations.
2

Under review as a conference paper at ICLR 2018

thus not requiring any modifications to the loss function and simplifying the optimization process, and is not limited to a predefined set of sample selection patterns.

3 MODEL DESCRIPTION
An RNN takes an input sequence x = (x1, . . . , xT ) and generates a state sequence s = (s1, . . . , sT ) by iteratively applying a parametric state transition model S from t = 1 to T :

st = S(st-1, xt)

(1)

We augment the network with a binary state update gate, ut  {0, 1}, selecting whether the state of the RNN will be updated (ut = 1) or copied from the previous time step (ut = 0). At every time step t, the probability u~t+1  [0, 1] of performing a state update at t + 1 is emitted. The resulting
architecture is depicted in Figure 1 and can be characterized as follows:

ut = fbinarize(u~t) st = ut · S(st-1, xt) + (1 - ut) · st-1 u~t = (Wpst + bp) u~t+1 = ut · u~t + (1 - ut) · (u~t + min(u~t, 1 - u~t))

(2) (3) (4) (5)

where Wp is a weights vector, bp is a scalar bias,  is the sigmoid function and fbinarize : [0, 1]  {0, 1} binarizes the input value. Should the network be composed of several layers, some columns
of Wp can be fixed to 0 so that u~t depends only on the states of a subset of layers (see Section A.3 for an example with two layers). We implement fbinarize as a deterministic step function ut = round(u~t), although a stochastic sampling from a Bernoulli distribution ut  Bernoulli(u~t) would be possible as well.

The model formulation implements the observation that the likelihood of requesting a new input to update the state increases with the number of consecutively skipped samples. Whenever a state update is omitted, the pre-activation of the state update gate for the following time step, u~t+1, is incremented by u~t. On the other hand, if a state update is performed, the accumulated value is flushed and u~t+1 = u~t.
The number of skipped time steps can be computed ahead of time. For the particular formulation used in this work, where fbinarize is implemented by means of a rounding function, the number of skipped samples after performing a state update at time step t is given by:

Nskip(t) = min{n : n · u~t  0.5} - 1

(6)

where n  Z+. This enables more efficient implementations where no computation at all is performed whenever ut = 0. These computational savings are possible because u~t = (Wpst+bp) = (Wpst-1 + bp) = u~t-1 when ut = 0 and there is no need to evaluate it again, as depicted in Figure 1d.

There are several advantages in reducing the number of RNN updates. From the computational standpoint, fewer updates translates into fewer required sequential operations to process an input signal, leading to faster inference and reduced energy consumption. Unlike some other models that aim to reduce the average number of operations per step (Neil et al., 2016; Jernite et al., 2017), ours enables skipping steps completely. Replacing RNN updates with copy operations increases the memory of the network and its ability to model long term dependencies even for gated units, since the exponential memory decay observed in LSTM and GRU (Neil et al., 2016) is alleviated. During training, gradients are propagated through fewer updating time steps, providing faster convergence in some tasks involving long sequences. Moreover, the proposed model is orthogonal to recent advances in RNNs and could be used in conjunction with such techniques, e.g. normalization (Cooijmans et al., 2017; Ba et al., 2016), regularization (Zaremba et al., 2015; Krueger et al., 2017), variable computation (Jernite et al., 2017; Neil et al., 2016) or even external memory (Graves et al., 2014; Weston et al., 2014).

3

Under review as a conference paper at ICLR 2018

+0

t fbinarize ut

1 t+1

t

t



0
st-1 S 1

st st-1

xt
(a)

S
xt
(b)

t


t+1 st

t + t+1 t + t+1

t


t-1

t

st-1 st st-1 st

xt (c)

xt (d)

Figure 1: Model architecture of the proposed Skip RNN. (a) Complete Skip RNN architecture,
where the computation graph at time step t is conditioned on ut. (b) Architecture when the state is updated, i.e. ut = 1. (c) Architecture when the update step is skipped and the previous state is copied, i.e. ut = 0. (d) In practice, redundant computation is avoided by propagating u~t between time steps when ut = 0.

3.1 ERROR GRADIENTS
The whole model is differentiable except for fbinarize, which outputs binary values. A common method for optimizing functions involving discrete variables is REINFORCE (Williams, 1992), although several estimators have been proposed for the particular case of neurons with binary outputs (Bengio et al., 2013). We select the straight-through estimator (Hinton, 2012), which consists in approximating the step function by the identity when computing gradients during the backward pass:

fbinarize (x) = 1 x

(7)

This yields a biased estimator that has proven more efficient than other unbiased but high-variance estimators such as REINFORCE (Bengio et al., 2013) and has been successfully applied in different works (Courbariaux et al., 2016; Chung et al., 2017). By using the straight-through estimator as the backward pass for fbinarize, all the model parameters can be trained to minimize the target loss function with standard backpropagation and without defining any additional supervision or reward signal.

3.2 LIMITING COMPUTATION
The Skip RNN is able to learn when to update or copy the state without explicit information about which samples are useful to solve the task at hand. However, a different operating point on the trade-off between performance and number of processed samples may be required depending on the application, e.g. one may be willing to sacrifice a few accuracy points in order to run faster on machines with a low computational power, or to reduce energy impact on portable devices. The proposed model can be encouraged to perform fewer state updates through additional loss terms, a

4

Under review as a conference paper at ICLR 2018

common practice in neural networks with dynamically allocated computation (Liu & Deng, 2017; McGill & Perona, 2017; Graves, 2016; Jernite et al., 2017). In particular, we consider a cost per sample:

T
Lbudget =  · ut
t=1

(8)

where Lbudget is the cost associated to a single sequence,  is the cost per sample and T is the sequence length. This formulation bears a similarity to weight decay regularization, where the network is encouraged to slowly converge towards a solution where the norm of the weights is smaller. Similarly, in this case the network is encouraged to converge towards a solution where fewer state updates are required.

Despite this formulation has been extensively studied in our experiments, different budget loss terms

can be used depending on the application. For instance, a specific number of samples may be

encouraged by applying an L1 or L2 loss between the target value and the number of updates per

sequence,

T t=1

ut

.

4 EXPERIMENTS
In the following section, we investigate the advantages of adding this state skipping to LSTMs and GRUs for a variety of tasks. In addition to the evaluation metric for each task, we also report the number of RNN state updates (i.e. the number of elements in the input sequence that are used by the model) as a measure of the computational load for each model. Since skipping an RNN update results in ignoring its corresponding input, we will refer to the number of updates and the number of used samples (i.e. elements in a sequence) interchangeably.
Training is performed with Adam (Kingma & Ba, 2014), learning rate of 10-4, 1 = 0.9, 2 = 0.999 and = 10-8 on batches of 256. Gradient clipping (Pascanu et al., 2013) with a threshold of 1 is applied to all trainable variables. Bias bp in Equation 4 is initialized to 1, so that all samples are used at the beginning of training2. The initial hidden state s0 is learned during training, whereas u~0 is set to a constant value of 1 in order to force the first update at t = 1.
Experiments are implemented with TensorFlow3 and run on a single NVIDIA K80 GPU.

4.1 ADDING TASK
We revisit one of the original LSTM tasks (Hochreiter & Schmidhuber, 1997), where the network is given a sequence of (value, marker) tuples. The desired output is the addition of only the two values that are marked with a 1, whereas those marked with a 0 need to be ignored. We follow the experimental setup by Neil et al. (2016), where the first marker is randomly placed among the first 10% of samples (drawn with uniform probability) and the second one is placed among the last half of samples (drawn with uniform probability). This marker distribution yields sequences where at least 40% of the samples are distractors and provide no useful information at all. However, it is worth noting that in this task the risk of missing a marker is very large as compared to the benefits of working on shorter subsequences.
We train RNN models with 110 units each on sequences of length 50, where the values are uniformly drawn from U(-0.5, 0.5). The final RNN state is fed to a fully connected layer that regresses the scalar output. The model is trained to minimize the Mean Squared Error (MSE) between the output and the ground truth. We consider that a model is able to solve the task when its MSE on a held-out set of examples is at least two orders of magnitude below the variance of the output distribution. This criterion is a stricter version of the one followed by Hochreiter & Schmidhuber (1997).
2In practice, forcing the network to use all samples at the beginning of training improves its robustness against random initializations of its weights and increases the reproducibility of the presented experiments. A similar behavior was observed in other augmented RNN architectures such as Neural Stacks (Grefenstette et al., 2015).
3https://www.tensorflow.org

5

Under review as a conference paper at ICLR 2018

Model
LSTM Skip LSTM,  = 0 Skip LSTM,  = 10-5
GRU Skip GRU,  = 0 Skip GRU,  = 10-5

Task solved
Yes Yes Yes
Yes Yes Yes

State updates
100.0% ± 0.0% 81.1% ± 3.6% 53.9% ± 2.1%
100.0% ± 0.0% 97.9% ± 3.2% 50.7% ± 2.6%

Table 1: Results for the adding task, displayed as mean ± std over four different runs. The task is considered to be solved if the MSE is at least two orders of magnitude below the variance of the output distribution.

While all models learn to solve the task, results in Table 1 show that Skip RNN models are able to do so with roughly half of the updates of their corresponding counterparts. We observed that the models using fewer updates never miss any marker, since the penalization in terms of MSE would be very large (see Section B.1 for examples). These models learn to skip most of the samples in the 40% of the sequence where there are no markers. Moreover, most updates are skipped once the second marker is found, since all the relevant information in the sequence has been already seen. This last pattern provides evidence that the proposed models effectively learn to decide whether to update or copy the hidden state based on the input sequence, as opposed to learning biases in the dataset only. As a downside, Skip RNN models show some difficulties skipping a large number of updates at once, probably due to the cumulative nature of u~t.
4.2 MNIST CLASSIFICATION FROM A SEQUENCE OF PIXELS
The MNIST handwritten digits classification benchmark (LeCun et al., 1998) is traditionally addressed with Convolutional Neural Networks (CNNs) that can efficiently exploit spatial dependencies through weight sharing. By flattening the 28 × 28 images into 784-d vectors, however, it can be reformulated as a challenging task for RNNs where long term dependencies need to be leveraged (Le et al., 2015). We follow the standard data split and set aside 5,000 training samples for validation purposes. After processing all pixels with an RNN with 110 units, the last hidden state is fed into a linear classifier predicting the digit class. All models are trained for 600 epochs to minimize cross-entropy loss. With the goal of studying the effect of skipping state updates on the learning capability of the networks, we introduce a new baseline which skips a state update with probability pskip. We tune the skipping probability to obtain models that perform a similar number of state updates to the Skip RNN models.
Table 2 summarizes classification results on the test set after 600 epochs of training. Skip RNNs are not only able to solve the task using fewer updates than their counterparts, but also show a lower variation among runs and train faster (see Figure 2). We hypothesize that skipping updates make the Skip RNNs work on shorter subsequences, simplifying the optimization process and allowing the networks to capture long term dependencies more easily. A similar behavior was observed for Phased LSTM, where increasing the sparsity of cell updates accelerates training for very long sequences (Neil et al., 2016). However, the drop in performance observed in the models where the state updates are skipped randomly suggests that learning which samples to use is a key component in the performance of Skip RNN.
Sequences of pixels can be reshaped back into 2D images, allowing to visualize the samples used by the RNNs as a sort of hard visual attention model (Xu et al., 2015). Examples such as the ones depicted in Figure 3 show how the model learns to skip pixels that are not discriminative, such as the padding regions in the top and bottom of images. Similarly to the qualitative results for the adding task (Section 4.1), attended samples vary depending on the particular input being given to the network.
6

Under review as a conference paper at ICLR 2018

Accuracy (%)

Model
LSTM LSTM (pskip = 0.5) Skip LSTM,  = 10-4
GRU GRU (pskip = 0.5) Skip GRU,  = 10-4

Accuracy
0.910 ± 0.045 0.893 ± 0.003 0.973 ± 0.002
0.968 ± 0.013 0.912 ± 0.004 0.976 ± 0.003

State updates
784.00 ± 0.00 392.03 ± 0.05 379.38 ± 33.09
784.00 ± 0.00 391.86 ± 0.14 392.62 ± 26.48

Table 2: Accuracy and used samples on the test set of MNIST after 600 epochs of training. Results are displayed as mean ± std over four different runs.

100 80 60 40 20
0

GRU Skip GRU, = 10 4

100

200 Ep3o0ch0s

400

500

600

Figure 2: Accuracy evolution during training on the validation set of MNIST. The Skip GRU exhibits lower variance and faster convergence than the baseline GRU. A similar behavior is observed for LSTM and Skip LSTM, but omitted for clarity. Shading shows maximum and minimum over 4 runs, while dark lines indicate the mean.

4.3 TEMPORAL ACTION LOCALIZATION ON CHARADES
One of the most accurate and scalable pipelines for video analysis consists in extracting frame level features with a CNN and modeling their temporal evolution with an RNN (Donahue et al., 2015; Yue-Hei Ng et al., 2015). Videos are commonly recorded at high sampling rates, rapidly generating long sequences with strong temporal redundancy that are challenging for RNNs. Moreover, processing frames with a CNN is computationally expensive and may become prohibitive for high framerates. These issues have been alleviated in previous works by using short clips (Donahue et al., 2015) or by downsampling the original data in order to cover long temporal spans without increasing the sequence length excessively (Yue-Hei Ng et al., 2015). Instead of addressing the long sequence problem at the input data level, we let the network learn which frames need to be used.
Charades (Sigurdsson et al., 2016a) is a dataset containing 9,848 videos annotated for 157 action classes in a per-frame fashion. Frames are encoded using fc7 features from the RGB stream of a Two-Stream CNN provided by the organizers of the challenge4, extracted at 6fps. The encoded frames are fed into two stacked RNN layers with 256 units each and the hidden state in the last RNN layer is used to compute the update probability for the Skip RNN models. Since each frame may be annotated with zero or more classes, the networks are trained to minimize element-wise binary cross-entropy at every time step. Unlike the previous sequence tagging tasks, this setup allows to evaluate the performance of Skip RNN on a task where the output is a sequence as well.
Evaluation is performed following the setup by Sigurdsson et al. (2016c) and results are reported in Table 3. Most Skip RNN models are able to achieve similar Mean Average Precision (mAP) to their counterparts while reducing the number of required state updates. A performance drop is observed when the cost per sample is high (e.g.  = 10-2) because the network is encouraged to use very
4http://vuchallenge.org/charades.html
7

Under review as a conference paper at ICLR 2018

Figure 3: Sample usage examples for the Skip LSTM with  = 10-4 on the test set of MNIST. Red pixels are used, whereas blue ones are skipped.

Model
LSTM Skip LSTM,  = 0 Skip LSTM,  = 10-4 Skip LSTM,  = 10-3 Skip LSTM,  = 10-2
GRU Skip GRU,  = 0 Skip GRU,  = 10-4 Skip GRU,  = 10-3 Skip GRU,  = 10-2

mAP (%)
8.48 8.40 8.64 8.41 7.93
8.77 9.02 8.78 8.76 8.01

State updates
172.9 ± 47.4 172.9 ± 47.4 172.9 ± 47.4 41.9 ± 11.3 17.4 ± 4.4
172.9 ± 47.4 159.9 ± 46.9 100.8 ± 28.1 54.2 ± 16.2 18.4 ± 5.1

Table 3: Mean Average Precision (mAP) and used samples on the validation set of Charades. The number of state updates is displayed as mean ± std over all the videos in the validation set.

few samples and may thus become more imprecise at predicting action boundaries. Interestingly, Skip GRU tends to perform fewer state updates than Skip LSTM when the cost per sample is low or none. This behavior is the opposite of the one observed in the adding task (Section 4.1), which may be related to the observation that determining the best performing gated unit depends on the task at hand Chung et al. (2014). Indeed, GRU models consistently outperform LSTM ones on this task. This mismatch in the number of used samples is not observed for large values of , as both Skip LSTM and Skip GRU converge to a comparable number of used samples.
5 CONCLUSION
We presented Skip RNNs as an extension to existing recurrent architectures enabling them to skip state updates thereby reducing the number of sequential operations in the computation graph. Unlike other approaches, all parameters in Skip RNN are trained with backpropagation. Experiments conducted with LSTMs and GRUs showed that Skip RNNs can match or in some cases even outperform the baseline models while relaxing their computational requirements. Skip RNNs provide faster and more stable training for long sequences and complex models, likely due to gradients being backpropagated through fewer time steps resulting in a simpler optimization task. Moreover, the introduced computational savings are better suited for modern hardware than those methods that reduce the amount of computation required at each time step (Koutnik et al., 2014; Neil et al., 2016; Chung et al., 2017).
REFERENCES
Amjad Almahairi, Nicolas Ballas, Tim Cooijmans, Yin Zheng, Hugo Larochelle, and Aaron Courville. Dynamic capacity networks. In ICML, 2016.
Jimmy Ba, Volodymyr Mnih, and Koray Kavukcuoglu. Multiple object recognition with visual attention. arXiv preprint arXiv:1412.7755, 2014.
8

Under review as a conference paper at ICLR 2018
Jimmy Lei Ba, Jamie Ryan Kiros, and Geoffrey E Hinton. Layer normalization. arXiv preprint arXiv:1607.06450, 2016.
Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. Neural machine translation by jointly learning to align and translate. In ICLR, 2015.
Yoshua Bengio. Deep learning of representations: Looking forward. In SLSP, 2013.
Yoshua Bengio, Patrice Simard, and Paolo Frasconi. Learning long-term dependencies with gradient descent is difficult. IEEE Transactions on Neural Networks, 1994.
Yoshua Bengio, Nicholas Le´onard, and Aaron Courville. Estimating or propagating gradients through stochastic neurons for conditional computation. arXiv preprint arXiv:1308.3432, 2013.
Subhabrata Bhattacharya, Felix X Yu, and Shih-Fu Chang. Minimally needed evidence for complex event recognition in unconstrained videos. In ICMR, 2014.
James Bradbury, Stephen Merity, Caiming Xiong, and Richard Socher. Quasi-recurrent neural networks. In ICLR, 2017.
Kyunghyun Cho, Bart Van Merrie¨nboer, Caglar Gulcehre, Dzmitry Bahdanau, Fethi Bougares, Holger Schwenk, and Yoshua Bengio. Learning phrase representations using rnn encoder-decoder for statistical machine translation. In EMNLP, 2014.
Junyoung Chung, Caglar Gulcehre, KyungHyun Cho, and Yoshua Bengio. Empirical evaluation of gated recurrent neural networks on sequence modeling. arXiv preprint arXiv:1412.3555, 2014.
Junyoung Chung, Sungjin Ahn, and Yoshua Bengio. Hierarchical multiscale recurrent neural networks. In ICLR, 2017.
Tim Cooijmans, Nicolas Ballas, Ce´sar Laurent, C¸ aglar Gu¨lc¸ehre, and Aaron Courville. Recurrent batch normalization. In ICLR, 2017.
Matthieu Courbariaux, Itay Hubara, Daniel Soudry, Ran El-Yaniv, and Yoshua Bengio. Binarized neural networks: Training deep neural networks with weights and activations constrained to+ 1 or-1. arXiv preprint arXiv:1602.02830, 2016.
Andrew Davis and Itamar Arel. Low-rank approximations for conditional feedforward computation in deep neural networks. arXiv preprint arXiv:1312.4461, 2013.
Jia Deng, Wei Dong, Richard Socher, Li-Jia Li, Kai Li, and Li Fei-Fei. ImageNet: A large-scale hierarchical image database. In CVPR, 2009.
Jeffrey Donahue, Lisa Anne Hendricks, Sergio Guadarrama, Marcus Rohrbach, Subhashini Venugopalan, Kate Saenko, and Trevor Darrell. Long-term recurrent convolutional networks for visual recognition and description. In CVPR, 2015.
Alex Graves. Adaptive computation time for recurrent neural networks. arXiv preprint arXiv:1603.08983, 2016.
Alex Graves, Abdel-rahman Mohamed, and Geoffrey Hinton. Speech recognition with deep recurrent neural networks. In ICASSP, 2013.
Alex Graves, Greg Wayne, and Ivo Danihelka. Neural turing machines. arXiv preprint arXiv:1410.5401, 2014.
Edward Grefenstette, Karl Moritz Hermann, Mustafa Suleyman, and Phil Blunsom. Learning to transduce with unbounded memory. In NIPS, 2015.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recognition. In CVPR, 2016.
Geoffrey Hinton. Neural networks for machine learning. Coursera video lectures, 2012.
Sepp Hochreiter and Ju¨rgen Schmidhuber. Long short-term memory. Neural computation, 1997.
9

Under review as a conference paper at ICLR 2018
Gao Huang, Yu Sun, Zhuang Liu, Daniel Sedra, and Kilian Q Weinberger. Deep networks with stochastic depth. In ECCV, 2016.
Yacine Jernite, Edouard Grave, Armand Joulin, and Tomas Mikolov. Variable computation in recurrent neural networks. In ICLR, 2017.
Yoon Kim. Convolutional neural networks for sentence classification. In EMNLP, 2014.
Diederik Kingma and Jimmy Ba. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980, 2014.
Jan Koutnik, Klaus Greff, Faustino Gomez, and Juergen Schmidhuber. A clockwork rnn. In ICML, 2014.
David Krueger, Tegan Maharaj, Ja´nos Krama´r, Mohammad Pezeshki, Nicolas Ballas, Nan Rosemary Ke, Anirudh Goyal, Yoshua Bengio, Hugo Larochelle, Aaron Courville, et al. Zoneout: Regularizing rnns by randomly preserving hidden activations. In ICLR, 2017.
Quoc V Le, Navdeep Jaitly, and Geoffrey E Hinton. A simple way to initialize recurrent networks of rectified linear units. arXiv preprint arXiv:1504.00941, 2015.
Yann LeCun, Le´on Bottou, Yoshua Bengio, and Patrick Haffner. Gradient-based learning applied to document recognition. Proceedings of the IEEE, 1998.
Tao Lei and Yu Zhang. Training rnns as fast as cnns. arXiv preprint arXiv:1709.02755, 2017.
Lanlan Liu and Jia Deng. Dynamic deep neural networks: Optimizing accuracy-efficiency trade-offs by selective execution. arXiv preprint arXiv:1701.00299, 2017.
Andrew L Maas, Raymond E Daly, Peter T Pham, Dan Huang, Andrew Y Ng, and Christopher Potts. Learning word vectors for sentiment analysis. In ACL, 2011.
Mason McGill and Pietro Perona. Deciding how to decide: Dynamic routing in artificial neural networks. In ICML, 2017.
Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg S Corrado, and Jeff Dean. Distributed representations of words and phrases and their compositionality. In NIPS, 2013.
Volodymyr Mnih, Nicolas Heess, Alex Graves, et al. Recurrent models of visual attention. In NIPS, 2014.
Daniel Neil, Michael Pfeiffer, and Shih-Chii Liu. Phased LSTM: accelerating recurrent network training for long or event-based sequences. In NIPS, 2016.
Razvan Pascanu, Tomas Mikolov, and Yoshua Bengio. On the difficulty of training recurrent neural networks. In ICML, 2013.
Colin Raffel and Dieterich Lawson. Training a subsampling mechanism in expectation. In ICLR Workshop Track, 2017.
Noam Shazeer, Azalia Mirhoseini, Krzysztof Maziarz, Andy Davis, Quoc Le, Geoffrey Hinton, and Jeff Dean. Outrageously large neural networks: The sparsely-gated mixture-of-experts layer. In ICLR, 2017.
Evan Shelhamer, Kate Rakelly, Judy Hoffman, and Trevor Darrell. Clockwork convnets for video semantic segmentation. arXiv preprint arXiv:1608.03609, 2016.
Gunnar Sigurdsson, Gu¨l Varol, Xiaolong Wang, Ali Farhadi, Ivan Laptev, and Abhinav Gupta. Hollywood in homes: Crowdsourcing data collection for activity understanding. In ECCV, 2016a.
Gunnar A Sigurdsson, Xinlei Chen, and Abhinav Gupta. Learning visual storylines with skipping recurrent neural networks. In ECCV, 2016b.
Gunnar A Sigurdsson, Santosh Divvala, Ali Farhadi, and Abhinav Gupta. Asynchronous temporal fields for action recognition. arXiv preprint arXiv:1612.06371, 2016c.
10

Under review as a conference paper at ICLR 2018
Khurram Soomro, Amir Roshan Zamir, and Mubarak Shah. Ucf101: A dataset of 101 human actions classes from videos in the wild. arXiv preprint arXiv:1212.0402, 2012.
Yu-Chuan Su and Kristen Grauman. Leaving some stones unturned: dynamic feature prioritization for activity detection in streaming video. In ECCV, 2016.
Jason Weston, Sumit Chopra, and Antoine Bordes. Memory networks. arXiv preprint arXiv:1410.3916, 2014.
Ronald J Williams. Simple statistical gradient-following algorithms for connectionist reinforcement learning. Machine learning, 1992.
Kelvin Xu, Jimmy Ba, Ryan Kiros, Kyunghyun Cho, Aaron Courville, Ruslan Salakhudinov, Rich Zemel, and Yoshua Bengio. Show, attend and tell: Neural image caption generation with visual attention. In ICML, 2015.
Serena Yeung, Olga Russakovsky, Greg Mori, and Li Fei-Fei. End-to-end learning of action detection from frame glimpses in videos. In CVPR, 2016.
Adams Wei Yu, Hongrae Lee, and Quoc V Le. Learning to skim text. In ACL, 2017.
Joe Yue-Hei Ng, Matthew Hausknecht, Sudheendra Vijayanarasimhan, Oriol Vinyals, Rajat Monga, and George Toderici. Beyond short snippets: Deep networks for video classification. In CVPR, 2015.
Wojciech Zaremba, Ilya Sutskever, and Oriol Vinyals. Recurrent neural network regularization. In ICLR, 2015.
A ADDITIONAL EXPERIMENTS
A.1 FREQUENCY DISCRIMINATION TASK
In this experiment, the network is trained to classify between sinusoids whose period is in range T  U (5, 6) milliseconds and those whose period is in range T  {(1, 5)  (6, 100)} milliseconds (Neil et al., 2016). Every sine wave with period T has a random phase shift drawn from U(0, T ). At every time step, the input to the network is a single scalar representing the amplitude of the signal. Since sinusoid are continuous signals, this tasks allows to study whether Skip RNNs converge to the same solutions when their parameters are fixed but the sampling period is changed. We study two different sampling periods, Ts = {0.5, 1} milliseconds, for each set of hyperparameters. We train RNNs with 110 units each on input signals of 100 milliseconds. Batches are stratified, containing the same number of samples for each class, yielding a 50% chance accuracy. The last state of the RNN is fed into a 2-way classifier and trained with cross-entropy loss. We consider that a model is able to solve the task when it achieves an accuracy over 99% on a held-out set of examples. Table 4 summarizes results for this task. When no cost per sample is set ( = 0), the number of updates differ under different sampling conditions. We attribute this behavior to the potentially large number of local minima in the cost function, since there are numerous subsampling patterns for which the task can be successfully solved and we are not explicitly encouraging the network to converge to a particular solution. On the other hand, when  > 0 Skip RNN models with the same cost per sample use roughly the same number of input samples even when the sampling frequency is doubled. This is a desirable property, since solutions are robust to oversampled input signals. Qualitative results can be found in Section B.2.
A.2 SENTIMENT ANALYSIS ON IMDB
The IMDB dataset (Maas et al., 2011) contains 25,000 training and 25,000 testing movie reviews annotated into two classes, positive and negative sentiment, with an approximate average length of 240 words per review. We set aside 15% of training data for validation purposes. Words are embedded into 300-d vector representations before being fed to an RNN with 128 units. The embedding
11

Under review as a conference paper at ICLR 2018

Model
LSTM Skip LSTM,  = 0 Skip LSTM,  = 10-5 Skip LSTM,  = 10-4
GRU Skip GRU,  = 0 Skip GRU,  = 10-5 Skip GRU,  = 10-4

Ts = 1ms (length 100)
Task solved State updates
Yes 100.0 ± 0.00 Yes 55.5 ± 16.9 Yes 47.4 ± 14.1 Yes 12.7 ± 0.5
Yes 100.0 ± 0.00 Yes 73.7 ± 17.9 Yes 51.9 ± 10.2 Yes 23.5 ± 6.2

Ts = 0.5ms (length 200)
Task solved State updates
Yes 200.0 ± 0.00 Yes 147.9 ± 27.0 Yes 50.7 ± 16.8 Yes 19.9 ± 1.5
Yes 200.0 ± 0.00 Yes 167.0 ± 18.3 Yes 54.2 ± 4.4 Yes 22.5 ± 2.1

Table 4: Results for the frequency discrimination task, displayed as mean ± std over four different runs. The task is considered to be solved if the classification accuracy is over 99%. Models with the same cost per sample ( > 0) converge to a similar number of used samples under different sampling conditions.

matrix is initialized using pre-trained word2vec5 embeddings (Mikolov et al., 2013) when available, or random vectors drawn from U(-0.25, 0.25) otherwise (Kim, 2014). Dropout with rate 0.2 is applied between the last RNN state and the classification layer in order to reduce overfitting. We evaluate the models on sequences of length 200 and 400 by cropping longer sequences and padding shorter ones (Yu et al., 2017).
Results on the test are reported in Table 5. In a task where it is hard to predict which input tokens will be discriminative, the Skip RNN models are able to achieve similar accuracy rates to the baseline models while reducing the number of required updates. These results highlight the trade-off between accuracy and the available computational budget, since a larger cost per sample results in lower accuracies. However, allowing the network to select which samples to use instead of cropping sequences at a given length boosts performance, as observed for the Skip LSTM (length 400,  = 10-4), which achieves a higher accuracy than the baseline LSTM (length 200) while seeing roughly the same number of words per review. A similar behavior can be seen for the Skip RNN models with  = 10-3, where allowing them to select words from longer reviews boosts classification accuracy while using a comparable number of tokens per sequence.

Model
LSTM Skip LSTM,  = 0 Skip LSTM,  = 10-5 Skip LSTM,  = 10-4 Skip LSTM,  = 10-3
GRU Skip GRU,  = 0 Skip GRU,  = 10-5 Skip GRU,  = 10-4 Skip GRU,  = 10-3

Length 200

Accuracy State updates

0.843 ± 0.003 0.844 ± 0.004 0.846 ± 0.004 0.837 ± 0.006 0.811 ± 0.007

200.00 ± 0.00 196.75 ± 5.63 197.15 ± 3.16 164.65 ± 8.67 73.85 ± 1.90

0.845 ± 0.006 0.848 ± 0.002 0.842 ± 0.005 0.834 ± 0.006 0.800 ± 0.007

200.00 ± 0.00 200.00 ± 0.00 199.25 ± 1.30 180.97 ± 8.90 106.15 ± 37.92

Length 400

Accuracy State updates

0.868 ± 0.004 0.866 ± 0.004 0.865 ± 0.001 0.862 ± 0.003 0.836 ± 0.007

400.00 ± 0.00 369.70 ± 19.35 380.62 ± 18.20 186.30 ± 25.72
84.22 ± 1.98

0.862 ± 0.003 0.866 ± 0.002 0.862 ± 0.008 0.853 ± 0.011 0.814 ± 0.005

400.00 ± 0.00 399.02 ± 1.69 398.00 ± 2.06 314.30 ± 2.82 99.12 ± 2.69

Table 5: Accuracy and used samples on the test set of IMDB for different sequence lengths. Results are displayed as mean ± std over four different runs.

5https://code.google.com/archive/p/word2vec/ 12

Accuracy (%)

Under review as a conference paper at ICLR 2018

Model
LSTM Skip LSTM,  = 0 Skip LSTM,  = 10-5 Skip LSTM,  = 10-4
GRU Skip GRU,  = 0 Skip GRU,  = 10-5 Skip GRU,  = 10-4

Accuracy
0.671 0.749 0.757 0.790
0.791 0.796 0.792 0.793

State updates
250.0 138.9 24.2 7.6
250.0 124.2 29.7 23.7

Table 6: Accuracy and used samples on the validation set of UCF-101 (split 1).
80

60

40 20 0
0

LSTM Skip LSTM, = 0 Skip LSTM, = 10 5 Skip LSTM, = 10 4 50 100 Epo1c5h0s 200 250 300

Figure 4: Accuracy evolution during the first 300 training epochs on the validation set of UCF-101 (split 1). Skip LSTM models converge much faster than the baseline LSTM.

A.3 ACTION CLASSIFICATION ON UCF-101
UCF-101 (Soomro et al., 2012) is a dataset containing 13,320 trimmed videos belonging to 101 different action categories. We use 10 seconds of video sampled at 25fps, cropping longer ones and padding shorter examples with empty frames. Activations in the Global Average Pooling layer from a ResNet-50 (He et al., 2016) CNN pretrained on the ImageNet dataset (Deng et al., 2009) are used as frame level features, which are fed into two stacked RNN layers with 512 units each. The weights in the CNN are not tuned during training to reduce overfitting. The hidden state in the last RNN layer is used to compute the update probability for the Skip RNN models.
We evaluate the different models on the first split of UCF-101 and report results in Table 6. Skip RNN models do not only improve the classification accuracy with respect to the baseline, but require very few updates to do so, possibly due to the low motion between consecutive frames resulting in frame level features with high temporal redundancy (Shelhamer et al., 2016). Moreover, Figure 4 shows how models performing fewer updates converge faster thanks to the gradients being preserved during longer spans when training with backpropagation through time.

13

Under review as a conference paper at ICLR 2018
B QUALITATIVE RESULTS
This appendix contains additional qualitative results for the Skip RNN models.
B.1 ADDING TASK

marker value

marker value

marker value

11

marker value

0 0 10 20time step 30 40 50
1

0 0 10 20time step 30 40 50
1

marker value

0 0 10 20time step 30 40 50
1

0 0 10 20time step 30 40 50
1

marker value

0 0 10 20time step 30 40 50
1

0 0 10 20time step 30 40 50
1

marker value

0 0 10 20time step 30 40 50
1

0 0 10 20time step 30 40 50
1

marker value

0 0 10 20time step 30 40 50

0 0 10 20time step 30 40 50

Figure 5: Sample usage examples for the Skip GRU with  = 10-5 on the adding task. Red dots indicate used samples, whereas blue ones are skipped.

14

marker value

marker value

amplitude

amplitude

amplitude

Under review as a conference paper at ICLR 2018

B.2 FREQUENCY DISCRIMINATION TASK

11

amplitude

00

1 0 25 50 75 sa1m0p0le 125 150 175 200
1

1 0 25 50 75 sa1m0p0le 125 150 175 200
1

amplitude

00

1 0 25 50 75 sa1m0p0le 125 150 175 200 1

1 0 25 50 75 sa1m0p0le 125 150 175 200 1

amplitude

00

1 0 25 50 75 sa1m0p0le 125 150 175 200
1

1 0 25 50 75 sa1m0p0le 125 150 175 200
1

amplitude

00

1 0 25 50 75 sa1m0p0le 125 150 175 200
1

1 0 25 50 75 sa1m0p0le 125 150 175 200
1

amplitude

00

1 0 25 50 75 sa1m0p0le 125 150 175 200

1 0 25 50 75 sa1m0p0le 125 150 175 200

Figure 6: Sample usage examples for the Skip LSTM with  = 10-4 on the frequency discrimination task with Ts = 0.5ms. Red dots indicate used samples, whereas blue ones are skipped. The network learns that using the first samples is enough to classify the frequency of the sine waves, in contrast to a uniform downsampling that may result in aliasing.

amplitude

amplitude

15

