Under review as a conference paper at ICLR 2018
LEARNING TO OPTIMIZE NEURAL NETS
Anonymous authors Paper under double-blind review
ABSTRACT
Learning to Optimize (Li & Malik, 2016) is a recently proposed framework for learning optimization algorithms using reinforcement learning. In this paper, we explore learning an optimization algorithm for training shallow neural nets. Such high-dimensional stochastic optimization problems present interesting challenges for existing reinforcement learning algorithms. We develop an extension that is suited to learning optimization algorithms in this setting and demonstrate that the learned optimization algorithm consistently outperforms other known optimization algorithms even on unseen tasks and is robust to changes in stochasticity of gradients and the neural net architecture. More specifically, we show that an optimization algorithm trained with the proposed method on the problem of training a neural net on MNIST generalizes to the problems of training neural nets on the Toronto Faces Dataset, CIFAR-10 and CIFAR-100.
1 INTRODUCTION
Machine learning is centred on the philosophy that learning patterns automatically from data is generally better than meticulously crafting rules by hand. This data-driven approach has delivered: today, machine learning techniques can be found in a wide range of application areas, both in AI and beyond. Yet, there is one domain that has conspicuously been left untouched by machine learning: the design of tools that power machine learning itself.
One of the most widely used tools in machine learning is optimization algorithms. We have grown accustomed to seeing an optimization algorithm as a black box that takes in a model that we design and the data that we collect and outputs the optimal model parameters. The optimization algorithm itself largely stays static: its design is reserved for human experts, who must toil through many rounds of theoretical analysis and empirical validation to devise a better optimization algorithm. Given this state of affairs, perhaps it is time for us to start practicing what we preach and learn how to learn.
Recently, Li & Malik (2016) and Andrychowicz et al. (2016) introduced two different frameworks for learning optimization algorithms. Whereas Andrychowicz et al. (2016) focuses on learning an optimization algorithm for training models on a particular task, Li & Malik (2016) sets a more ambitious objective of learning an optimization algorithm for training models that is task-independent. We study the latter paradigm in this paper and develop a method for learning an optimization algorithm for high-dimensional stochastic optimization problems, like the problem of training shallow neural nets.
Under the "Learning to Optimize" framework proposed by Li & Malik (2016), the problem of learning an optimization algorithm is formulated as a reinforcement learning problem. We consider the general structure of an unconstrained continuous optimization algorithm, as shown in Algorithm 1. In each iteration, the algorithm takes a step x and uses it to update the current iterate x(i). In hand-engineered optimization algorithms, x is computed using some fixed formula  that depends on the objective function, the current iterate and past iterates. Often, it is simply a function of the current and past gradients.
Different choices of  yield different optimization algorithms and so each optimization algorithm is essentially characterized by its update formula . Hence, by learning , we can learn an optimization algorithm. Li & Malik (2016) observed that an optimization algorithm can be viewed as a Markov decision process (MDP), where the state includes the current iterate, the action is the step vector x
1

Under review as a conference paper at ICLR 2018
Algorithm 1 General structure of optimization algorithms Require: Objective function f
x(0)  random point in the domain of f for i = 1, 2, . . . do
x  (f, {x(0), . . . , x(i-1)}) if stopping condition is met then
return x(i-1) end if x(i)  x(i-1) + x end for
and the policy is the update formula . Hence, the problem of learning  simply reduces to a policy search problem.
In this paper, we build on the method proposed in (Li & Malik, 2016) and develop an extension that is suited to learning optimization algorithms for high-dimensional stochastic problems. We use it to learn an optimization algorithm for training shallow neural nets and show that it outperforms popular hand-engineered optimization algorithms like ADAM (Kingma & Ba, 2014), AdaGrad (Duchi et al., 2011) and RMSprop (Tieleman & Hinton, 2012) and an optimization algorithm learned using the supervised learning method proposed in (Andrychowicz et al., 2016). Furthermore, we demonstrate that our optimization algorithm learned from the experience of training on MNIST generalizes to training on other datasets that have very dissimilar statistics, like the Toronto Faces Dataset, CIFAR10 and CIFAR-100.
2 RELATED WORK
The line of work on learning optimization algorithms is fairly recent. Li & Malik (2016) and Andrychowicz et al. (2016) were the first to propose learning general optimization algorithms. Li & Malik (2016) explored learning task-independent optimization algorithms and used reinforcement learning to learn the optimization algorithm, while Andrychowicz et al. (2016) investigated learning task-dependent optimization algorithms and used supervised learning.
In the special case where objective functions that the optimization algorithm is trained on are loss functions for training other models, these methods can be used for "learning to learn" or "metalearning". While these terms have appeared from time to time in the literature (Baxter et al., 1995; Vilalta & Drissi, 2002; Brazdil et al., 2008; Thrun & Pratt, 2012), they have been used by different authors to refer to disparate methods with different purposes. These methods all share the objective of learning some form of meta-knowledge about learning, but differ in the type of meta-knowledge they aim to learn. We can divide the various methods into the following three categories.
2.1 LEARNING WHAT TO LEARN
Methods in this category Thrun & Pratt (2012) aim to learn what parameter values of the base-level learner are useful across a family of related tasks. The meta-knowledge captures commonalities shared by tasks in the family, which enables learning on a new task from the family to be performed more quickly. Most early methods fall into this category; this line of work has blossomed into an area that has later become known as transfer learning and multi-task learning.
2.2 LEARNING WHICH MODEL TO LEARN
Methods in this category Brazdil et al. (2008) aim to learn which base-level learner achieves the best performance on a task. The meta-knowledge captures correlations between different tasks and the performance of different base-level learners on those tasks. One challenge under this setting is to decide on a parameterization of the space of base-level learners that is both rich enough to be capable of representing disparate base-level learners and compact enough to permit tractable search over this space. Brazdil et al. (2003) proposes a nonparametric representation and stores examples of different base-level learners in a database, whereas Schmidhuber (2004) proposes representing base-
2

Under review as a conference paper at ICLR 2018

level learners as general-purpose programs. The former has limited representation power, while the latter makes search and learning in the space of base-level learners intractable. Hochreiter et al. (2001) views the (online) training procedure of any base-learner as a black box function that maps a sequence of training examples to a sequence of predictions and models it as a recurrent neural net. Under this formulation, meta-training reduces to training the recurrent net, and the base-level learner is encoded in the memory state of the recurrent net.
Hyperparameter optimization can be seen as another example of methods in this category. The space of base-level learners to search over is parameterized by a predefined set of hyperparameters. Unlike the methods above, multiple trials with different hyperparameter settings on the same task are permitted, and so generalization across tasks is not required. The discovered hyperparameters are generally specific to the task at hand and hyperparameter optimization must be rerun for new tasks. Various kinds of methods have been proposed, such those based on Bayesian optimization (Hutter et al., 2011; Bergstra et al., 2011; Snoek et al., 2012; Swersky et al., 2013; Feurer et al., 2015), random search (Bergstra & Bengio, 2012) and gradient-based optimization (Bengio, 2000; Domke, 2012; Maclaurin et al., 2015).
2.3 LEARNING HOW TO LEARN
Methods in this category aim to learn a good algorithm for training a base-level learner. Unlike methods in the previous categories, the goal is not to learn about the outcome of learning, but rather the process of learning. The meta-knowledge captures commonalities in the behaviours of learning algorithms that achieve good performance. The base-level learner and the task are given by the user, so the learned algorithm must generalize across base-level learners and tasks. Since learning in most cases is equivalent to optimizing some objective function, learning a learning algorithm often reduces to learning an optimization algorithm. This problem was explored in (Li & Malik, 2016) and (Andrychowicz et al., 2016). Closely related is (Bengio et al., 1991), which learns a Hebblike synaptic learning rule that does not depend on the objective function, which does not allow for generalization to different objective functions.
Various work has explored learning how to adjust the hyperparameters of hand-engineered optimization algorithms, like the step size (Hansen, 2016; Daniel et al., 2016; Fu et al., 2016) or the damping factor in the Levenberg-Marquardt algorithm (Ruvolo et al., 2009). Related to this line of work is stochastic meta-descent (Bray et al., 2004), which derives a rule for adjusting the step size analytically. A different line of work (Gregor & LeCun, 2010; Sprechmann et al., 2013) parameterizes intermediate operands of special-purpose solvers for a class of optimization problems that arise in sparse coding and learns them using supervised learning.

3 LEARNING TO OPTIMIZE

3.1 SETTING

In the "Learning to Optimize" framework, we are given a set of training objective functions

f1, . . . , fn drawn from some distribution F . An optimization algorithm P takes an objective function f and an initial iterate x(0) as input and produces a sequence of iterates x(1), . . . , x(T ), where

x(T ) is the solution found by the optimizer. We are also given a distribution D that generates

the initial iterate x(0) and a meta-loss L, which takes an objective function f and a sequence of

iterates x(1), . . . , x(T ) produced by an optimization algorithm as input and outputs a scalar that measures the quality of the iterates. The goal is to learn an optimization algorithm P such that

EfF,x(0)D L(f, P(f, x(0))) is minimized. The meta-loss is chosen to penalize optimization algorithms that exhibit behaviours we find undesirable, like slow convergence or excessive oscilla-

tions. Assuming we would like to learn an algorithm that minimizes the objective function it is given,

a good choice of meta-loss would then simply be

T i=1

f (x(i)),

which

is

equivalent

to

cumulative

regret and can be interpreted as the area under the curve of objective values over time.

The objective functions f1, . . . , fn may correspond to loss functions for training base-level learners, in which case the algorithm that learns the optimization algorithm can be viewed as a meta-learner. In this setting, each objective function is the loss function for training a particular base-learner on a particular task, and so the set of training objective functions can be loss functions for training a

3

Under review as a conference paper at ICLR 2018

base-learner or a family of base-learners on different tasks. At test time, the learned optimization algorithm is evaluated on unseen objective functions, which correspond to loss functions for training base-learners on new tasks, which may be completely unrelated to tasks used for training the optimization algorithm. Therefore, the learned optimization algorithm must not learn anything about the tasks used for training. Instead, the goal is to learn an optimization algorithm that can exploit the geometric structure of the error surface induced by the base-learners. For example, if the base-level model is a neural net with ReLU activation units, the optimization algorithm should hopefully learn to leverage the piecewise linearity of the model. Hence, there is a clear division of responsibilities between the meta-learner and base-learners. The knowledge learned at the meta-level should be pertinent for all tasks, whereas the knowledge learned at the base-level should be task-specific. The meta-learner should therefore generalize across tasks, whereas the base-learner should generalize across instances.

3.2 RL PRELIMINARIES

The goal of reinforcement learning is to learn to interact with an environment in a way that minimizes cumulative costs that are expected to be incurred over time. The environment is formalized as a partially observable Markov decision process (POMDP)1, which is defined by the tuple (S, O, A, pi, p, po, c, T ), where S  RD is the set of states, O  RD is the set of observations, A  Rd is the set of actions, pi (s0) is the probability density over initial states s0, p (st+1 |st, at ) is the probability density over the subsequent state st+1 given the current state st and action at, po (ot |st ) is the probability density over the current observation ot given the current state st, c : S  R is a function that assigns a cost to each state and T is the time horizon. Often, the probability densities p and po are unknown and not given to the learning algorithm.
A policy  (at |ot, t ) is a conditional probability density over actions at given the current observation ot and time step t. When a policy is independent of t, it is known as a stationary policy. The goal of the reinforcement learning algorithm is to learn a policy  that minimizes the total expected cost over time. More precisely,



=

arg

min


Es0

,a0

,s1

,...,sT

T
c(st) ,
t=0

where the expectation is taken with respect to the joint distribution over the sequence of states and actions, often referred to as a trajectory, which has the density

q(s0, a0,s1, . . . , sT ) =

pi (s0) po ( o0| s0)

o0 ,...,oT

T -1

 ( at| ot, t) p ( st+1| st, at) po ( ot+1| st+1) .

t=0

To make learning tractable,  is often constrained to lie in a parameterized family. A common assumption is that  ( at| ot, t) = N (µ(ot), (ot)), where N (µ, ) denotes the density of a Gaussian with mean µ and covariance . The functions µ(·) and possibly (·) are modelled
using function approximators, whose parameters are learned.

3.3 FORMULATION
In our setting, the state st consists of the current iterate x(t) and features (·) that depend on the history of iterates x(1), . . . , x(t), (noisy) gradients f^(x(1)), . . . , f^(x(t)) and (noisy) objective values f^(x(1)), . . . , f^(x(t)). The action at is the step x that will be used to update the iterate. The observation ot excludes x(t) and consists of features (·) that depend on the iterates, gradient and objective values from recent iterations, and the previous memory state of the learned optimization algorithm, which takes the form of a recurrent neural net. This memory state can be viewed as a statistic of the previous observations that is learned jointly with the policy.
1What is described is an undiscounted finite-horizon POMDP with continuous state, observation and action spaces.

4

Under review as a conference paper at ICLR 2018

Under this formulation, the initial probability density pi captures how the initial iterate, gradient and objective value tend to be distributed. The transition probability density p captures the how the gradient and objective value are likely to change given the step that is taken currently; in other words, it encodes the local geometry of the training objective functions. Assuming the goal is to learn an optimization algorithm that minimizes the objective function, the cost c of a state st = x(t),  (·) T is simply the true objective value f (x(t)).
Any particular policy  (at |ot, t ), which generates at = x at every time step, corresponds to a particular (noisy) update formula , and therefore a particular (noisy) optimization algorithm. Therefore, learning an optimization algorithm simply reduces to searching for the optimal policy.
The mean of the policy is modelled as a recurrent neural net fragment that corresponds to a single time step, which takes the observation features (·) and the previous memory state as input and outputs the step to take.

3.4 GUIDED POLICY SEARCH

The reinforcement learning method we use is guided policy search (GPS) (Levine et al., 2015), which is a policy search method designed for searching over large classes of expressive non-linear policies in continuous state and action spaces. It maintains two policies,  and , where the former lies in a time-varying linear policy class in which the optimal policy can found in closed form, and the latter lies in a stationary non-linear policy class in which policy optimization is challenging. In each iteration, it performs policy optimization on , and uses the resulting policy as supervision to train .
More precisely, GPS solves the following constrained optimization problem:

T

min E

c(st) s.t.  ( at| st, t; ) =  ( at| st; ) at, st, t

,

t=0

where  and  denote the parameters of  and  respectively, E [·] denotes the expectation taken with respect to the trajectory induced by a policy  and  ( at| st; ) := ot  ( at| ot; ) po ( ot| st)2.
Since there are an infinite number of equality constraints, the problem is relaxed by enforcing equality on the mean actions taken by  and  at every time step3. So, the problem becomes:

T

min E

c(st) s.t. E [at] = E [E [ at| st]] t

,

t=0

This problem is solved using Bregman ADMM (Wang & Banerjee, 2014), which performs the following updates in each iteration:

T

  arg min 

E c(st) - Tt at + tDt (, )

t=0

T
  arg min tT E [E [ at| st]] + tDt (, )  t=0

t  t + t (E [E [ at| st]] - E [at]) t,

where Dt (, ) := E [DKL (  ( at| st; )  ( at| st, t; ))] and Dt (, ) E [DKL (  ( at| st, t; )  ( at| st; ))].

:=

The algorithm  ( at| ot; ) =

assumes that  N (µ (ot), 

( at| st, t; ) = N ), where  := (,

(Ktst + ) and

µkt,(G·)tc),anwbheeraenar:=bit(raKryt,fkutn,cGtito)nTt=t1haatnids

typically modelled using a nonlinear function approximator like a neural net.

2In practice, the explicit form of the observation probability po is usually not known or the integral may be
intractable to compute. So, a linear Gaussian model is fitted to samples of st and at and used in place of the true  ( at| st; ) where necessary.
3Though the Bregman divergence penalty is applied to the original probability distributions over at.

5

Under review as a conference paper at ICLR 2018

At the start of each iteration, the algorithm constructs a model of the transition probability density

p~( st+1| st, at, t; ) = N (Atst + Btat + ct, Ft), where  := (At, Bt, ct, Ft)tT=1 is fitted to samples of st drawn from the trajectory induced by , which essentially amounts to a local linearization of the true transition probability p ( st+1| st, at, t). We will use E~ [·] to denote expectation taken with
respect to the trajectory induced by  under the modelled transition probability p~. Additionally, the

algorithm fits local quadratic approximations to c(st) around samples of st drawn from the trajectory

induced

by



so

that

c(st)



c~(st)

:=

1 2

sTt

Ctst

+

dTt st

+ ht

for

st's

that

are

near

the

samples.

With these assumptions, the subproblem that needs to be solved to update  = (Kt, kt, Gt)Tt=1 becomes:

T

min 

E~ c~(st) - tT at + tDt (, )

t=0

T

s.t. E~ DKL  ( at| st, t; )  at| st, t; 
t=0

,

where  denotes the old  from the previous iteration. Because p~ and c~ are only valid locally around the trajectory induced by , the constraint is added to limit the amount by which  is updated. It turns out that the unconstrained problem can be solved in closed form using a dynamic programming algorithm known as linear-quadratic-Gaussian (LQG) regulator in time linear in the time horizon T and cubic in the dimensionality of the state space D. The constrained problem is solved using dual gradient descent, which uses LQG as a subroutine to solve for the primal variables in each iteration and increments the dual variable on the constraint until it is satisfied.

Updating  is straightforward, since expectations taken with respect to the trajectory induced by 
are always conditioned on st and all outer expectations over st are taken with respect to the trajectory induced by . Therefore,  is essentially decoupled from the transition probability p ( st+1| st, at, t) and so its parameters can be updated without affecting the distribution of st's. The subproblem that needs to be solved to update  therefore amounts to a standard supervised learning problem.

Since  ( at| st, t; ) and  ( at| st; ) are Gaussian, Dt (, ) can be computed analytically. More concretely, if we assume  to be fixed for simplicity, the subproblem that is solved for updating  = (, ) is:

min E 

T

tT µ(ot)

+

t 2

tr G-t 1

- log ||

t=0

+ t 2

(µ (ot)

-

E

[ at| st, t])T

Gt-1

(µ (ot )

-

E

[ at| st, t])

Note that the last term is the squared Mahalanobis distance between the mean actions of  and  at time step t, which is intuitive as we would like to encourage  to match .

3.5 CONVOLUTIONAL GPS
The problem of learning high-dimensional optimization algorithms presents challenges for reinforcement learning algorithms due to high dimensionality of the state and action spaces. For example, in the case of GPS, because the running time of LQG is cubic in dimensionality of the state space, performing policy search even in the simple class of linear-Gaussian policies would be prohibitively expensive when the dimensionality of the optimization problem is high.
Fortunately, many high-dimensional optimization problems have underlying structure that can be exploited. For example, the parameters of neural nets are equivalent up to permutation among certain coordinates. More concretely, for fully connected neural nets, the dimensions of a hidden layer and the corresponding weights can be permuted arbitrarily without changing the function they compute. Because permuting the dimensions of two adjacent layers can permute the weight matrix arbitrarily, an optimization algorithm should be invariant to permutations of the rows and columns of a weight matrix. A reasonable prior to impose is that the algorithm should behave in the same

6

Under review as a conference paper at ICLR 2018

Objective Value Objective Value Objective Value

Gradient Descent

Momentum

40

Conjugate Gradient L-BFGS

AdaGrad

ADAM

30

RMSprop L2LBGDBGD

Predicted Step Descent

20

10

0 50 100 150 200 250 300 350 Iteration
(a)

Gradient Descent

Momentum

50 Conjugate Gradient

L-BFGS

AdaGrad

40

ADAM RMSprop

L2LBGDBGD

Predicted Step Descent

30

20

10

0 50 100 150 200 250 300 350 Iteration

(b)

100

Gradient Descent Momentum

Conjugate Gradient

L-BFGS

80

AdaGrad ADAM

RMSprop

L2LBGDBGD

60 Predicted Step Descent

40

20 0 50 100 150 200 250 300 350 Iteration
(c)

Figure 1: Comparison of the various hand-engineered and learned algorithms on training neural nets with 48 input and hidden units on (a) TFD, (b) CIFAR-10 and (c) CIFAR-100 with mini-batches of size 64. The vertical axis is the true objective value and the horizontal axis represents the iteration. Best viewed in colour.

manner on all coordinates that correspond to entries in the same matrix. That is, if the values of two coordinates in all current and past gradients and iterates are identical, then the step vector produced by the algorithm should have identical values in these two coordinates. We will refer to the set of coordinates on which permutation invariance is enforced as a coordinate group. For the purposes of learning an optimization algorithm for neural nets, a natural choice would be to make each coordinate group correspond to a weight matrix or a bias vector. Hence, the total number of coordinate groups is twice the number of layers, which is usually fairly small.
In the case of GPS, we impose this prior on both  and . For the purposes of updating , we first impose a block-diagonal structure on the parameters At, Bt and Ft of the fitted transition probability density p~( st+1| st, at, t; ) = N (Atst + Btat + ct, Ft), so that for each coordinate in the optimization problem, the dimensions of st+1 that correspond to the coordinate only depend on the dimensions of st and at that correspond to the same coordinate. As a result, p~( st+1| st, at, t; ) decomposes into multiple independent probability densities p~j stj+1 sjt , ajt , t; j , one for each
coordinate j. Similarly, we also impose a block-diagonal structure on Ct for fitting c~(st) and on the parameter matrix of the fitted model for  ( at| st; ). Under these assumptions, Kt and Gt are guaranteed to be block-diagonal as well. Hence, the Bregman divergence penalty term, D (, ) decomposes into a sum of Bregman divergence terms, one for each coordinate.
We then further constrain dual variables t, sub-vectors of parameter vectors and sub-matrices of parameter matrices corresponding to each coordinate group to be identical across the group. Additionally, we replace the weight t on D (, ) with an individual weight on each Bregman divergence term for each coordinate group. The problem then decomposes into multiple independent subproblems, one for each coordinate group. Because the dimensionality of the state subspace corresponding to each coordinate is constant, LQG can be executed on each subproblem much more efficiently.
Similarly, for , we choose a µ(·) that shares parameters across different coordinates in the same group. We also impose a block-diagonal structure on  and constrain the appropriate sub-matrices to share their entries.

3.6 FEATURES

We describe the features (·) and (·) at time step t, which define the state st and observation ot respectively.

Because of the stochasticity of gradients and objective values, the state features (·) are defined

in terms of summary statistics of the history of iterates

x(i)

t
i=0, gradients

f^(x(i)) t and
i=0

objective values f^(x(i)) t . We define the following statistics, which we will refer to as the

i=0
average recent iterate, gradient and objective value respectively:

·

x(i) :=

1 min(i+1,3)

i j=max(i-2,0)

x(j)

7

Under review as a conference paper at ICLR 2018

Objective Value Objective Value Objective Value

200

Gradient Descent Momentum

Conjugate Gradient

L-BFGS

AdaGrad

150

ADAM RMSprop

L2LBGDBGD

Predicted Step Descent

100

50

0 50 100 150 200 250 300 350 Iteration
(a)

Gradient Descent

200

Momentum Conjugate Gradient

L-BFGS

AdaGrad

ADAM

150 RMSprop

L2LBGDBGD

Predicted Step Descent

100

50

0 50 100 150 200 250 300 350 Iteration
(b)

350

Gradient Descent Momentum

Conjugate Gradient

300

L-BFGS AdaGrad

250

ADAM RMSprop

L2LBGDBGD

200 Predicted Step Descent

150

100 50

0 50 100 150 200 250 300 350 Iteration

(c)

Figure 2: Comparison of the various hand-engineered and learned algorithms on training neural nets with 100 input units and 200 hidden units on (a) TFD, (b) CIFAR-10 and (c) CIFAR-100 with minibatches of size 64. The vertical axis is the true objective value and the horizontal axis represents the iteration. Best viewed in colour.

·

f^(x(i)) :=

1 min(i+1,3)

i j=max(i-2,0)

f^(x(j))

·

f^(x(i)) :=

1 min(i+1,3)

i j=max(i-2,0)

f^(x(j))

The state features (·) consist of the relative change in the average recent objective value, the average recent gradient normalized by the magnitude of the a previous average recent gradient and a previous change in average recent iterate relative to the current change in average recent iterate:

· f^(x(t-5i)) - f^(x(t-5(i+1))) /f^(x(t-5(i+1))) 24
i=0

· f^(x(t-5i))/ f^(x(max(t-5(i+1),tmod5))) + 1 25
i=0

x(max(t-5(i+1),tmod5+5)) -x(max(t-5(i+2),tmod5))

24

·

x(t-5i)-x(t-5(i+1)) +0.1

i=0

Note that all operations are applied element-wise. Also, whenever a feature becomes undefined (i.e.: when the time step index becomes negative), it is replaced with the all-zeros vector.

Unlike state features, which are only used when training the optimization algorithm, observation features (·) are used both during training and at test time. Consequently, we use noisier observation features that can be computed more efficiently and require less memory overhead. The observation features consist of the following:

· f^(x(t)) - f^(x(t-1)) /f^(x(t-1)) · f^(x(t))/ f^(x(max(t-1,0))) + 1
| |x(max(t-1,1))-x(max(t-2,0)) · | |x(t)-x(t-1) +0.1

4 EXPERIMENTS

For clarity, we will refer to training of the optimization algorithm as "meta-training" to differentiate it from base-level training, which will simply be referred to as "training".
We meta-trained an optimization algorithm on a single objective function, which corresponds to the problem of training a two-layer neural net with 48 input units, 48 hidden units and 10 output units on a randomly projected and normalized version of the MNIST training set with dimensionality 48 and unit variance in each dimension. We modelled the optimization algorithm using an recurrent neural net with a single layer of 128 LSTM (Hochreiter & Schmidhuber, 1997) cells. We used a time horizon of 400 iterations and a mini-batch size of 64 for computing stochastic gradients and objective values. We evaluate the optimization algorithm on its ability to generalize to unseen objective functions, which correspond to the problems of training neural nets on different tasks/datasets.

8

Under review as a conference paper at ICLR 2018

Objective Value Objective Value Objective Value

Gradient Descent

Momentum

40

Conjugate Gradient L-BFGS

AdaGrad

ADAM

30

RMSprop L2LBGDBGD

Predicted Step Descent

20

10 0 50 100 150 200 250 300 350 Iteration
(a)

Gradient Descent

Momentum

50 Conjugate Gradient

L-BFGS

AdaGrad

40

ADAM RMSprop

L2LBGDBGD

Predicted Step Descent

30

20

10 0 50 100 150 200 250 300 350 Iteration

(b)

100

Gradient Descent Momentum

Conjugate Gradient

L-BFGS

80

AdaGrad ADAM

RMSprop

L2LBGDBGD

60 Predicted Step Descent

40

20 0 50 100 150 200 250 300 350 Iteration
(c)

Figure 3: Comparison of the various hand-engineered and learned algorithms on training neural nets with 48 input and hidden units on (a) TFD, (b) CIFAR-10 and (c) CIFAR-100 with mini-batches of size 10. The vertical axis is the true objective value and the horizontal axis represents the iteration. Best viewed in colour.

Objective Value Objective Value Objective Value

200

Gradient Descent Momentum

Conjugate Gradient

L-BFGS

AdaGrad

150

ADAM RMSprop

L2LBGDBGD

Predicted Step Descent

100

50

0 50 100 150 200 250 300 350 Iteration
(a)

Gradient Descent

200

Momentum Conjugate Gradient

L-BFGS

AdaGrad

ADAM

150 RMSprop

L2LBGDBGD

Predicted Step Descent

100

50

0 50 100 150 200 250 300 350 Iteration
(b)

350

Gradient Descent Momentum

Conjugate Gradient

300

L-BFGS AdaGrad

250

ADAM RMSprop

L2LBGDBGD

200 Predicted Step Descent

150

100 50

0 50 100 150 200 250 300 350 Iteration

(c)

Figure 4: Comparison of the various hand-engineered and learned algorithms on training neural nets with 100 input units and 200 hidden units on (a) TFD, (b) CIFAR-10 and (c) CIFAR-100 with minibatches of size 10. The vertical axis is the true objective value and the horizontal axis represents the iteration. Best viewed in colour.

We evaluate the learned optimization algorithm on three datasets, the Toronto Faces Dataset (TFD), CIFAR-10 and CIFAR-100. These datasets are chosen for their very different characteristics from MNIST and each other: TFD contains 3300 grayscale images that have relatively little variation and has seven different categories, whereas CIFAR-100 contains 50,000 colour images that have varied appearance and has 100 different categories.
All algorithms are tuned on the training objective function. For hand-engineered algorithms, this entails choosing the best hyperparameters; for learned algorithms, this entails meta-training on the objective function. We compare to the seven hand-engineered algorithms: stochastic gradient descent, momentum, conjugate gradient, L-BFGS, ADAM, AdaGrad and RMSprop. In addition, we compare to an optimization algorithm meta-trained using the method described in (Andrychowicz et al., 2016) on the same training objective function (training two-layer neural net on randomly projected and normalized MNIST) under the same setting (a time horizon of 400 iterations and a mini-batch size of 64).
First, we examine the performance of various optimization algorithms on similar objective functions. The optimization problems under consideration are those for training neural nets that have the same number of input and hidden units (48 and 48) as those used during meta-training. The number of output units varies with the number of categories in each dataset. We use the same mini-batch size as that used during meta-training. As shown in Figure 1, the optimization algorithm meta-trained using our method (which we will refer to as Predicted Step Descent) consistently descends to the optimum the fastest across all datasets. On the other hand, other algorithms are not as consistent and the relative ranking of other algorithms varies by dataset. This suggests that Predicted Step Descent has learned to be robust to variations in the data distributions, despite being trained on only one objective function, which is associated with a very specific data distribution that characterizes MNIST. It is also interesting to note that while the algorithm meta-trained using (Andrychowicz
9

Under review as a conference paper at ICLR 2018

Objective Value Objective Value Objective Value

200

Gradient Descent Momentum

Conjugate Gradient

L-BFGS

AdaGrad

150

ADAM RMSprop

L2LBGDBGD

Predicted Step Descent

100

50

0 100 200 300 400 500 600 700 Iteration
(a)

Gradient Descent

200

Momentum Conjugate Gradient

L-BFGS

AdaGrad

ADAM

150 RMSprop

L2LBGDBGD

Predicted Step Descent

100

50

0 100 200 300 400 500 600 700 Iteration
(b)

350

Gradient Descent Momentum

Conjugate Gradient

300

L-BFGS AdaGrad

250

ADAM RMSprop

L2LBGDBGD

200 Predicted Step Descent

150

100

50

0 100 200 300 400 500 600 700 Iteration

(c)

Figure 5: Comparison of the various hand-engineered and learned algorithms on training neural nets with 100 input units and 200 hidden units on (a) TFD, (b) CIFAR-10 and (c) CIFAR-100 for 800 iterations with mini-batches of size 64. The vertical axis is the true objective value and the horizontal axis represents the iteration. Best viewed in colour.

et al., 2016) (which we will refer to as L2LBGDBGD) performs well on CIFAR, it is unable to reach the optimum on TFD.
Next, we change the architecture of the neural nets and see if Predicted Step Descent generalizes to the new architecture. We increase the number of input units to 100 and the number of hidden units to 200, so that the number of parameters is roughly increased by a factor of 8. As shown in Figure 2, Predicted Step Descent consistently outperforms other algorithms on each dataset, despite having not been trained to optimize neural nets of this architecture. Interestingly, while it exhibited a bit of oscillation initially on TFD and CIFAR-10, it quickly recovered and overtook other algorithms, which is reminiscent of the phenomenon reported in (Li & Malik, 2016) for low-dimensional optimization problems. This suggests that it has learned to detect when it is performing poorly and knows how to change tack accordingly. L2LBGDBGD experienced difficulties on TFD and CIFAR10 as well, but slowly diverged.
We now investigate how robust Predicted Step Descent is to stochasticity of the gradients. To this end, we take a look at its performance when we reduce the mini-batch size from 64 to 10 on both the original architecture with 48 input and hidden units and the enlarged architecture with 100 input units and 200 hidden units. As shown in Figure 3, on the original architecture, Predicted Step Descent still outperforms all other algorithms and is able to handle the increased stochasticity fairly well. In contrast, conjugate gradient and L2LBGDBGD had some difficulty handling the increased stochasticity on TFD and to a lesser extent, on CIFAR-10. In the former case, both diverged; in the latter case, both were progressing slowly towards the optimum.
On the enlarged architecture, Predicted Step Descent experienced some significant oscillations on TFD and CIFAR-10, but still managed to achieve a much better objective value than all the other algorithms. Many hand-engineered algorithms also experienced much greater oscillations than previously, suggesting that the optimization problems are inherently harder. L2LBGDBGD diverged fairly quickly on these two datasets.
Finally, we try doubling the number of iterations. As shown in Figure 5, despite being trained over a time horizon of 400 iterations, Predicted Step Descent behaves reasonably beyond the number of iterations it is trained for.
5 CONCLUSION
In this paper, we presented a new method for learning optimization algorithms for high-dimensional stochastic problems. We applied the method to learning an optimization algorithm for training shallow neural nets. We showed that the algorithm learned using our method on the problem of training a neural net on MNIST generalizes to the problems of training neural nets on unrelated tasks/datasets like the Toronto Faces Dataset, CIFAR-10 and CIFAR-100. We also demonstrated that the learned optimization algorithm is robust to changes in the stochasticity of gradients and the neural net architecture.
10

Under review as a conference paper at ICLR 2018
REFERENCES
Marcin Andrychowicz, Misha Denil, Sergio Gomez, Matthew W Hoffman, David Pfau, Tom Schaul, and Nando de Freitas. Learning to learn by gradient descent by gradient descent. arXiv preprint arXiv:1606.04474, 2016.
Jonathan Baxter, Rich Caruana, Tom Mitchell, Lorien Y Pratt, Daniel L Silver, and Sebastian Thrun. NIPS 1995 workshop on learning to learn: Knowledge consolidation and transfer in inductive systems. https://web.archive.org/web/20000618135816/http://www. cs.cmu.edu/afs/cs.cmu.edu/user/caruana/pub/transfer.html, 1995. Accessed: 2015-12-05.
Y Bengio, S Bengio, and J Cloutier. Learning a synaptic learning rule. In Neural Networks, 1991., IJCNN-91-Seattle International Joint Conference on, volume 2, pp. 969­vol. IEEE, 1991.
Yoshua Bengio. Gradient-based optimization of hyperparameters. Neural computation, 12(8):1889­ 1900, 2000.
James Bergstra and Yoshua Bengio. Random search for hyper-parameter optimization. The Journal of Machine Learning Research, 13(1):281­305, 2012.
James S Bergstra, Re´mi Bardenet, Yoshua Bengio, and Bala´zs Ke´gl. Algorithms for hyper-parameter optimization. In Advances in Neural Information Processing Systems, pp. 2546­2554, 2011.
M Bray, E Koller-Meier, P Muller, L Van Gool, and NN Schraudolph. 3D hand tracking by rapid stochastic gradient descent using a skinning model. In Visual Media Production, 2004.(CVMP). 1st European Conference on, pp. 59­68. IET, 2004.
Pavel Brazdil, Christophe Giraud Carrier, Carlos Soares, and Ricardo Vilalta. Metalearning: applications to data mining. Springer Science & Business Media, 2008.
Pavel B Brazdil, Carlos Soares, and Joaquim Pinto Da Costa. Ranking learning algorithms: Using ibl and meta-learning on accuracy and time results. Machine Learning, 50(3):251­277, 2003.
Christian Daniel, Jonathan Taylor, and Sebastian Nowozin. Learning step size controllers for robust neural network training. In Thirtieth AAAI Conference on Artificial Intelligence, 2016.
Justin Domke. Generic methods for optimization-based modeling. In AISTATS, volume 22, pp. 318­326, 2012.
John Duchi, Elad Hazan, and Yoram Singer. Adaptive subgradient methods for online learning and stochastic optimization. Journal of Machine Learning Research, 12(Jul):2121­2159, 2011.
Matthias Feurer, Jost Tobias Springenberg, and Frank Hutter. Initializing bayesian hyperparameter optimization via meta-learning. In AAAI, pp. 1128­1135, 2015.
Jie Fu, Zichuan Lin, Miao Liu, Nicholas Leonard, Jiashi Feng, and Tat-Seng Chua. Deep q-networks for accelerating the training of deep neural networks. arXiv preprint arXiv:1606.01467, 2016.
Karol Gregor and Yann LeCun. Learning fast approximations of sparse coding. In Proceedings of the 27th International Conference on Machine Learning (ICML-10), pp. 399­406, 2010.
Samantha Hansen. Using deep q-learning to control optimization hyperparameters. arXiv preprint arXiv:1602.04062, 2016.
Sepp Hochreiter and Ju¨rgen Schmidhuber. Long short-term memory. Neural computation, 9(8): 1735­1780, 1997.
Sepp Hochreiter, A Steven Younger, and Peter R Conwell. Learning to learn using gradient descent. In International Conference on Artificial Neural Networks, pp. 87­94. Springer, 2001.
Frank Hutter, Holger H Hoos, and Kevin Leyton-Brown. Sequential model-based optimization for general algorithm configuration. In Learning and Intelligent Optimization, pp. 507­523. Springer, 2011.
11

Under review as a conference paper at ICLR 2018
Diederik Kingma and Jimmy Ba. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980, 2014.
Sergey Levine, Chelsea Finn, Trevor Darrell, and Pieter Abbeel. End-to-end training of deep visuomotor policies. arXiv preprint arXiv:1504.00702, 2015.
Ke Li and Jitendra Malik. Learning to optimize. CoRR, abs/1606.01885, 2016. Dougal Maclaurin, David Duvenaud, and Ryan P Adams. Gradient-based hyperparameter optimiza-
tion through reversible learning. arXiv preprint arXiv:1502.03492, 2015. Paul L Ruvolo, Ian Fasel, and Javier R Movellan. Optimization on a budget: A reinforcement
learning approach. In Advances in Neural Information Processing Systems, pp. 1385­1392, 2009. Ju¨rgen Schmidhuber. Optimal ordered problem solver. Machine Learning, 54(3):211­254, 2004. Jasper Snoek, Hugo Larochelle, and Ryan P Adams. Practical bayesian optimization of machine
learning algorithms. In Advances in neural information processing systems, pp. 2951­2959, 2012. Pablo Sprechmann, Roee Litman, Tal Ben Yakar, Alexander M Bronstein, and Guillermo Sapiro.
Supervised sparse analysis and synthesis operators. In Advances in Neural Information Processing Systems, pp. 908­916, 2013. Kevin Swersky, Jasper Snoek, and Ryan P Adams. Multi-task bayesian optimization. In Advances in neural information processing systems, pp. 2004­2012, 2013. Sebastian Thrun and Lorien Pratt. Learning to learn. Springer Science & Business Media, 2012. Tijmen Tieleman and Geoffrey Hinton. Lecture 6.5-rmsprop: Divide the gradient by a running average of its recent magnitude. COURSERA: Neural networks for machine learning, 4(2), 2012. Ricardo Vilalta and Youssef Drissi. A perspective view and survey of meta-learning. Artificial Intelligence Review, 18(2):77­95, 2002. Huahua Wang and Arindam Banerjee. Bregman alternating direction method of multipliers. CoRR, abs/1306.3203, 2014.
12

